
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/opd-ai/go-netrek/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/opd-ai/go-netrek/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/opd-ai/go-netrek/examples/ai_client/main.go (0.0%)</option>
				
				<option value="file3">github.com/opd-ai/go-netrek/examples/simple_server/main.go (0.0%)</option>
				
				<option value="file4">github.com/opd-ai/go-netrek/pkg/config/config.go (96.0%)</option>
				
				<option value="file5">github.com/opd-ai/go-netrek/pkg/engine/game.go (71.7%)</option>
				
				<option value="file6">github.com/opd-ai/go-netrek/pkg/entity/entity.go (62.5%)</option>
				
				<option value="file7">github.com/opd-ai/go-netrek/pkg/entity/planet.go (96.2%)</option>
				
				<option value="file8">github.com/opd-ai/go-netrek/pkg/entity/ship.go (96.3%)</option>
				
				<option value="file9">github.com/opd-ai/go-netrek/pkg/entity/weapon.go (100.0%)</option>
				
				<option value="file10">github.com/opd-ai/go-netrek/pkg/event/event.go (96.8%)</option>
				
				<option value="file11">github.com/opd-ai/go-netrek/pkg/network/client.go (24.5%)</option>
				
				<option value="file12">github.com/opd-ai/go-netrek/pkg/network/server.go (1.0%)</option>
				
				<option value="file13">github.com/opd-ai/go-netrek/pkg/physics/collision.go (87.0%)</option>
				
				<option value="file14">github.com/opd-ai/go-netrek/pkg/physics/ship.go (100.0%)</option>
				
				<option value="file15">github.com/opd-ai/go-netrek/pkg/physics/vector.go (100.0%)</option>
				
				<option value="file16">github.com/opd-ai/go-netrek/pkg/render/engo/assets.go (13.1%)</option>
				
				<option value="file17">github.com/opd-ai/go-netrek/pkg/render/engo/camera.go (71.4%)</option>
				
				<option value="file18">github.com/opd-ai/go-netrek/pkg/render/engo/hud.go (0.0%)</option>
				
				<option value="file19">github.com/opd-ai/go-netrek/pkg/render/engo/input.go (0.0%)</option>
				
				<option value="file20">github.com/opd-ai/go-netrek/pkg/render/engo/renderer.go (0.0%)</option>
				
				<option value="file21">github.com/opd-ai/go-netrek/pkg/render/engo/scene.go (15.4%)</option>
				
				<option value="file22">github.com/opd-ai/go-netrek/pkg/render/renderer.go (100.0%)</option>
				
				<option value="file23">github.com/opd-ai/go-netrek/pkg/render/terminal.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// cmd/client/main.go
package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/EngoEngine/engo"

        "github.com/opd-ai/go-netrek/pkg/config"
        "github.com/opd-ai/go-netrek/pkg/event"
        "github.com/opd-ai/go-netrek/pkg/network"
        engorender "github.com/opd-ai/go-netrek/pkg/render/engo"
)

func main() <span class="cov0" title="0">{
        args := parseCommandLineArguments()
        gameConfig := loadGameConfiguration(args.configPath)
        serverAddr := resolveServerAddress(args.serverAddr, gameConfig)

        eventBus := event.NewEventBus()
        client := initializeGameClient(eventBus, serverAddr, args.playerName, args.teamID)
        setupEventSubscriptions(eventBus)
        startSelectedRenderer(args.renderer, client, eventBus, args.teamID, args.width, args.height, args.fullscreen)
}</span>

// clientArgs holds parsed command line arguments for the client application.
type clientArgs struct {
        configPath string
        serverAddr string
        playerName string
        teamID     int
        renderer   string
        fullscreen bool
        width      int
        height     int
}

// parseCommandLineArguments parses and returns command line arguments for the client.
func parseCommandLineArguments() *clientArgs <span class="cov0" title="0">{
        args := &amp;clientArgs{}
        flag.StringVar(&amp;args.configPath, "config", "config.json", "Path to configuration file")
        flag.StringVar(&amp;args.serverAddr, "server", "", "Server address (overrides config)")
        flag.StringVar(&amp;args.playerName, "name", "Player", "Player name")
        flag.IntVar(&amp;args.teamID, "team", 0, "Team ID")
        flag.StringVar(&amp;args.renderer, "renderer", "terminal", "Renderer type: 'terminal' or 'engo'")
        flag.BoolVar(&amp;args.fullscreen, "fullscreen", false, "Run in fullscreen mode (Engo only)")
        flag.IntVar(&amp;args.width, "width", 1024, "Window width (Engo only)")
        flag.IntVar(&amp;args.height, "height", 768, "Window height (Engo only)")
        flag.Parse()
        return args
}</span>

// loadGameConfiguration loads the game configuration from file or returns default configuration.
func loadGameConfiguration(configPath string) *config.GameConfig <span class="cov0" title="0">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Configuration file not found, using default configuration")
                return config.DefaultConfig()
        }</span>

        <span class="cov0" title="0">gameConfig, err := config.LoadConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>
        <span class="cov0" title="0">return gameConfig</span>
}

// resolveServerAddress determines the final server address to use for connection.
func resolveServerAddress(cmdLineAddr string, gameConfig *config.GameConfig) string <span class="cov0" title="0">{
        if cmdLineAddr == "" </span><span class="cov0" title="0">{
                return gameConfig.NetworkConfig.ServerAddress
        }</span>
        <span class="cov0" title="0">return cmdLineAddr</span>
}

// initializeGameClient creates and connects a new game client to the server.
func initializeGameClient(eventBus *event.Bus, serverAddr, playerName string, teamID int) *network.GameClient <span class="cov0" title="0">{
        client := network.NewGameClient(eventBus)

        log.Printf("Connecting to server at %s", serverAddr)
        if err := client.Connect(serverAddr, playerName, teamID); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to server: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Connected to server")

        return client</span>
}

// setupEventSubscriptions configures all event handlers for client-server communication.
func setupEventSubscriptions(eventBus *event.Bus) <span class="cov0" title="0">{
        eventBus.Subscribe(network.ChatMessageReceived, func(e event.Event) </span><span class="cov0" title="0">{
                if chatEvent, ok := e.(*network.ChatEvent); ok </span><span class="cov0" title="0">{
                        fmt.Printf("[%s]: %s\n", chatEvent.SenderName, chatEvent.Message)
                }</span>
        })

        <span class="cov0" title="0">eventBus.Subscribe(network.ClientDisconnected, func(e event.Event) </span><span class="cov0" title="0">{
                log.Printf("Disconnected from server")
        }</span>)

        <span class="cov0" title="0">eventBus.Subscribe(network.ClientReconnected, func(e event.Event) </span><span class="cov0" title="0">{
                log.Printf("Reconnected to server")
        }</span>)

        <span class="cov0" title="0">eventBus.Subscribe(network.ClientReconnectFailed, func(e event.Event) </span><span class="cov0" title="0">{
                log.Printf("Failed to reconnect to server")
                os.Exit(1)
        }</span>)
}

// startSelectedRenderer launches the appropriate renderer based on user selection.
func startSelectedRenderer(renderer string, client *network.GameClient, eventBus *event.Bus, teamID, width, height int, fullscreen bool) <span class="cov0" title="0">{
        switch renderer </span>{
        case "engo":<span class="cov0" title="0">
                startEngoRenderer(client, eventBus, uint64(teamID), width, height, fullscreen)</span>
        case "terminal":<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                startTerminalRenderer(client, eventBus)</span>
        }
}

// startEngoRenderer starts the Engo GUI client
func startEngoRenderer(client *network.GameClient, eventBus *event.Bus, playerID uint64, width, height int, fullscreen bool) <span class="cov0" title="0">{
        // Create the game scene
        scene := engorender.NewGameScene(client, eventBus, playerID)

        // Configure Engo options
        opts := engo.RunOptions{
                Title:      "Go Netrek",
                Width:      width,
                Height:     height,
                Fullscreen: fullscreen,
                VSync:      true,
        }

        // Run Engo with the game scene
        engo.Run(opts, scene)
}</span>

// startTerminalRenderer starts the terminal-based client (existing implementation)
func startTerminalRenderer(client *network.GameClient, eventBus *event.Bus) <span class="cov0" title="0">{
        // Handle game state updates
        go func() </span><span class="cov0" title="0">{
                for gameState := range client.GetGameStateChannel() </span><span class="cov0" title="0">{
                        // Process game state
                        // In a real client, this would update the game view
                        log.Printf("Received game state update: tick=%d ships=%d planets=%d",
                                gameState.Tick, len(gameState.Ships), len(gameState.Planets))
                }</span>
        }()

        // Example input simulation (in a real client, this would be based on user input)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        // Send input every 100ms
                        time.Sleep(100 * time.Millisecond)

                        // Example input: thrust, turn right, fire weapon 0
                        client.SendInput(true, false, true, 0, false, false, 0, 0)
                }</span>
        }()

        // Example chat message
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                time.Sleep(3 * time.Second)
                log.Printf("Sending chat message")
                client.SendChatMessage("Hello, Netrek!")
        }</span>()

        // Handle graceful shutdown
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Disconnecting from server...")
        client.Disconnect()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// cmd/server/main.go
package main

import (
        "flag"
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/opd-ai/go-netrek/pkg/config"
        "github.com/opd-ai/go-netrek/pkg/engine"
        "github.com/opd-ai/go-netrek/pkg/network"
)

func main() <span class="cov0" title="0">{
        configPath := flag.String("config", "config.json", "Path to configuration file")
        createDefault := flag.Bool("default", false, "Create default configuration file")
        flag.Parse()

        // Create default configuration file if requested
        if *createDefault </span><span class="cov0" title="0">{
                defaultConfig := config.DefaultConfig()
                if err := config.SaveConfig(defaultConfig, *configPath); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to create default configuration: %v", err)
                }</span>
                <span class="cov0" title="0">log.Printf("Created default configuration file: %s", *configPath)
                return</span>
        }

        // Load configuration
        <span class="cov0" title="0">var gameConfig *config.GameConfig

        if _, err := os.Stat(*configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Configuration file not found, using default configuration")
                gameConfig = config.DefaultConfig()
        }</span> else<span class="cov0" title="0"> {
                gameConfig, err = config.LoadConfig(*configPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to load configuration: %v", err)
                }</span>
        }

        // Create game
        <span class="cov0" title="0">game := engine.NewGame(gameConfig)

        // Create server
        server := network.NewGameServer(game, gameConfig.MaxPlayers)

        // Start server
        serverAddr := gameConfig.NetworkConfig.ServerAddress
        if serverAddr == "" </span><span class="cov0" title="0">{
                serverAddr = "localhost:4566"
        }</span>

        <span class="cov0" title="0">log.Printf("Starting server on %s", serverAddr)
        if err := server.Start(serverAddr); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>

        // Handle graceful shutdown
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down server...")
        server.Stop()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// examples/ai_client/main.go
// AI-controlled client bot demonstrating different behaviors
package main

import (
        "flag"
        "log"
        "math"
        "math/rand/v2"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/opd-ai/go-netrek/pkg/engine"
        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/event"
        "github.com/opd-ai/go-netrek/pkg/network"
        "github.com/opd-ai/go-netrek/pkg/physics"
)

// AIBehavior defines different AI behaviors
type AIBehavior int

const (
        BehaviorExplorer  AIBehavior = iota // Flies around exploring
        BehaviorAggressor                   // Seeks and attacks enemies
        BehaviorDefender                    // Defends home planets
        BehaviorBomber                      // Attacks enemy planets
)

// AIClient represents an AI-controlled game client
type AIClient struct {
        client         *network.GameClient
        eventBus       *event.Bus
        behavior       AIBehavior
        playerName     string
        teamID         int
        lastGameState  *engine.GameState
        myShipID       entity.ID
        targetPlanetID entity.ID
        targetShipID   entity.ID
        lastActionTime time.Time
        actionCooldown time.Duration
        random         *rand.Rand
}

func main() <span class="cov0" title="0">{
        // Command line flags
        serverAddr := flag.String("server", "localhost:4566", "Server address")
        playerName := flag.String("name", "AIBot", "Player name")
        teamID := flag.Int("team", 0, "Team ID (0 or 1)")
        behaviorStr := flag.String("behavior", "explorer", "AI behavior (explorer, aggressor, defender, bomber)")
        flag.Parse()

        // Parse behavior
        var behavior AIBehavior
        switch *behaviorStr </span>{
        case "explorer":<span class="cov0" title="0">
                behavior = BehaviorExplorer</span>
        case "aggressor":<span class="cov0" title="0">
                behavior = BehaviorAggressor</span>
        case "defender":<span class="cov0" title="0">
                behavior = BehaviorDefender</span>
        case "bomber":<span class="cov0" title="0">
                behavior = BehaviorBomber</span>
        default:<span class="cov0" title="0">
                log.Fatalf("Unknown behavior: %s", *behaviorStr)</span>
        }

        <span class="cov0" title="0">log.Printf("Starting AI Client: %s (Team %d, Behavior: %s)", *playerName, *teamID, *behaviorStr)

        // Create AI client
        aiClient := NewAIClient(*playerName, *teamID, behavior)

        // Connect to server
        if err := aiClient.Connect(*serverAddr); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to server: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Connected to server at %s", *serverAddr)
        log.Printf("AI behavior: %s", getBehaviorDescription(behavior))

        // Handle graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down AI client...")
        aiClient.Disconnect()</span>
}

// NewAIClient creates a new AI client
func NewAIClient(playerName string, teamID int, behavior AIBehavior) *AIClient <span class="cov0" title="0">{
        eventBus := event.NewEventBus()

        ai := &amp;AIClient{
                client:         network.NewGameClient(eventBus),
                eventBus:       eventBus,
                behavior:       behavior,
                playerName:     playerName,
                teamID:         teamID,
                actionCooldown: time.Millisecond * 200, // Act every 200ms
                random:         rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(teamID))),
        }

        // Subscribe to events
        ai.setupEventHandlers()

        return ai
}</span>

// Connect connects to the game server
func (ai *AIClient) Connect(serverAddr string) error <span class="cov0" title="0">{
        if err := ai.client.Connect(serverAddr, ai.playerName, ai.teamID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start AI behavior loop
        <span class="cov0" title="0">go ai.behaviorLoop()

        return nil</span>
}

// Disconnect disconnects from the server
func (ai *AIClient) Disconnect() <span class="cov0" title="0">{
        ai.client.Disconnect()
}</span>

// setupEventHandlers sets up event handling
func (ai *AIClient) setupEventHandlers() <span class="cov0" title="0">{
        ai.eventBus.Subscribe(network.ChatMessageReceived, func(e event.Event) </span><span class="cov0" title="0">{
                if chatEvent, ok := e.(*network.ChatEvent); ok </span><span class="cov0" title="0">{
                        log.Printf("[Chat] %s: %s", chatEvent.SenderName, chatEvent.Message)
                }</span>
        })

        <span class="cov0" title="0">ai.eventBus.Subscribe(network.ClientDisconnected, func(e event.Event) </span><span class="cov0" title="0">{
                log.Printf("Disconnected from server")
                os.Exit(0)
        }</span>)
}

// behaviorLoop runs the main AI behavior loop
func (ai *AIClient) behaviorLoop() <span class="cov0" title="0">{
        // Game state processing
        go func() </span><span class="cov0" title="0">{
                for gameState := range ai.client.GetGameStateChannel() </span><span class="cov0" title="0">{
                        ai.lastGameState = gameState
                        ai.updateMyShipID(gameState)
                }</span>
        }()

        // Main behavior loop
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                time.Sleep(ai.actionCooldown)

                if ai.lastGameState == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Execute behavior based on type
                <span class="cov0" title="0">ai.executeBehavior()
                ai.lastActionTime = time.Now()</span>
        }
}

// updateMyShipID finds and updates the AI's ship ID
func (ai *AIClient) updateMyShipID(gameState *engine.GameState) <span class="cov0" title="0">{
        // Find our ship by looking for ships belonging to our team
        for shipID, shipState := range gameState.Ships </span><span class="cov0" title="0">{
                if shipState.TeamID == ai.teamID </span><span class="cov0" title="0">{
                        // For simplicity, assume first ship found is ours
                        // In a real implementation, we'd track player-to-ship mapping
                        ai.myShipID = shipID
                        break</span>
                }
        }
}

// executeBehavior executes the AI's current behavior
func (ai *AIClient) executeBehavior() <span class="cov0" title="0">{
        if ai.myShipID == 0 </span><span class="cov0" title="0">{
                return // Don't have a ship yet
        }</span>

        <span class="cov0" title="0">myShip, exists := ai.lastGameState.Ships[ai.myShipID]
        if !exists </span><span class="cov0" title="0">{
                return // Ship doesn't exist
        }</span>

        <span class="cov0" title="0">switch ai.behavior </span>{
        case BehaviorExplorer:<span class="cov0" title="0">
                ai.executeExplorerBehavior(myShip)</span>
        case BehaviorAggressor:<span class="cov0" title="0">
                ai.executeAggressorBehavior(myShip)</span>
        case BehaviorDefender:<span class="cov0" title="0">
                ai.executeDefenderBehavior(myShip)</span>
        case BehaviorBomber:<span class="cov0" title="0">
                ai.executeBomberBehavior(myShip)</span>
        }
}

// executeExplorerBehavior makes the AI explore the galaxy
func (ai *AIClient) executeExplorerBehavior(myShip engine.ShipState) <span class="cov0" title="0">{
        // Simple exploration: move in random directions, occasionally change course
        thrust := true
        turnLeft := false
        turnRight := false

        // Randomly change direction
        if ai.random.Float64() &lt; 0.1 </span><span class="cov0" title="0">{ // 10% chance to turn
                if ai.random.Float64() &lt; 0.5 </span><span class="cov0" title="0">{
                        turnLeft = true
                }</span> else<span class="cov0" title="0"> {
                        turnRight = true
                }</span>
        }

        // Send input
        <span class="cov0" title="0">ai.client.SendInput(thrust, turnLeft, turnRight, -1, false, false, 0, 0)

        // Occasionally send a friendly message
        if ai.random.Float64() &lt; 0.005 </span><span class="cov0" title="0">{ // 0.5% chance
                messages := []string{
                        "Exploring the galaxy!",
                        "Beautiful stars out here",
                        "Anyone seen any interesting planets?",
                        "The universe is vast",
                }
                msg := messages[ai.random.IntN(len(messages))]
                ai.client.SendChatMessage(msg)
        }</span>
}

// executeAggressorBehavior makes the AI seek and attack enemies
func (ai *AIClient) executeAggressorBehavior(myShip engine.ShipState) <span class="cov0" title="0">{
        // Find the nearest enemy ship
        nearestEnemy := ai.findNearestEnemyShip(myShip.Position)

        thrust := true
        turnLeft := false
        turnRight := false
        fireWeapon := -1

        if nearestEnemy != nil </span><span class="cov0" title="0">{
                // Calculate angle to enemy
                targetVector := nearestEnemy.Position.Sub(myShip.Position)
                targetAngle := targetVector.Angle()

                // Calculate angle difference
                angleDiff := targetAngle - myShip.Rotation

                // Normalize angle difference to [-π, π]
                for angleDiff &gt; math.Pi </span><span class="cov0" title="0">{
                        angleDiff -= 2 * math.Pi
                }</span>
                <span class="cov0" title="0">for angleDiff &lt; -math.Pi </span><span class="cov0" title="0">{
                        angleDiff += 2 * math.Pi
                }</span>

                // Turn towards enemy
                <span class="cov0" title="0">if math.Abs(angleDiff) &gt; 0.1 </span><span class="cov0" title="0">{
                        if angleDiff &gt; 0 </span><span class="cov0" title="0">{
                                turnLeft = true
                        }</span> else<span class="cov0" title="0"> {
                                turnRight = true
                        }</span>
                }

                // Fire if pointing roughly at enemy
                <span class="cov0" title="0">distance := targetVector.Length()
                if math.Abs(angleDiff) &lt; 0.3 &amp;&amp; distance &lt; 1000 </span><span class="cov0" title="0">{
                        fireWeapon = 0 // Fire first weapon
                }</span>

                // Taunt enemies occasionally
                <span class="cov0" title="0">if ai.random.Float64() &lt; 0.01 </span><span class="cov0" title="0">{
                        ai.client.SendChatMessage("Prepare for battle!")
                }</span>
        }

        <span class="cov0" title="0">ai.client.SendInput(thrust, turnLeft, turnRight, fireWeapon, false, false, 0, 0)</span>
}

// executeDefenderBehavior makes the AI defend home planets
func (ai *AIClient) executeDefenderBehavior(myShip engine.ShipState) <span class="cov0" title="0">{
        homePlanet := ai.findHomePlanet()

        thrust, turnLeft, turnRight := ai.initializeDefenseInputs()

        if homePlanet != nil </span><span class="cov0" title="0">{
                distance := ai.calculateDistanceToHome(myShip.Position, homePlanet.Position)

                if distance &gt; 500 </span><span class="cov0" title="0">{
                        turnLeft, turnRight = ai.calculateNavigationToHome(myShip, homePlanet)
                }</span> else<span class="cov0" title="0"> {
                        turnLeft, turnRight = ai.executePatrolBehavior()
                }</span>
        }

        <span class="cov0" title="0">ai.client.SendInput(thrust, turnLeft, turnRight, -1, false, false, 0, 0)</span>
}

// initializeDefenseInputs sets up the default input state for defensive behavior.
func (ai *AIClient) initializeDefenseInputs() (thrust bool, turnLeft bool, turnRight bool) <span class="cov0" title="0">{
        return true, false, false
}</span>

// calculateDistanceToHome computes the distance between the ship and home planet.
func (ai *AIClient) calculateDistanceToHome(shipPosition, homePosition physics.Vector2D) float64 <span class="cov0" title="0">{
        homeVector := homePosition.Sub(shipPosition)
        return homeVector.Length()
}</span>

// calculateNavigationToHome determines turn direction to navigate toward the home planet.
func (ai *AIClient) calculateNavigationToHome(myShip engine.ShipState, homePlanet *engine.PlanetState) (turnLeft bool, turnRight bool) <span class="cov0" title="0">{
        homeVector := homePlanet.Position.Sub(myShip.Position)
        targetAngle := homeVector.Angle()
        angleDiff := ai.normalizeAngleDifference(targetAngle - myShip.Rotation)

        return ai.determineTurnDirection(angleDiff)
}</span>

// normalizeAngleDifference normalizes angle difference to the range [-π, π].
func (ai *AIClient) normalizeAngleDifference(angleDiff float64) float64 <span class="cov0" title="0">{
        for angleDiff &gt; math.Pi </span><span class="cov0" title="0">{
                angleDiff -= 2 * math.Pi
        }</span>
        <span class="cov0" title="0">for angleDiff &lt; -math.Pi </span><span class="cov0" title="0">{
                angleDiff += 2 * math.Pi
        }</span>
        <span class="cov0" title="0">return angleDiff</span>
}

// determineTurnDirection decides whether to turn left or right based on angle difference.
func (ai *AIClient) determineTurnDirection(angleDiff float64) (turnLeft bool, turnRight bool) <span class="cov0" title="0">{
        if math.Abs(angleDiff) &gt; 0.1 </span><span class="cov0" title="0">{
                if angleDiff &gt; 0 </span><span class="cov0" title="0">{
                        return true, false
                }</span>
                <span class="cov0" title="0">return false, true</span>
        }
        <span class="cov0" title="0">return false, false</span>
}

// executePatrolBehavior implements random patrol movement around the home planet.
func (ai *AIClient) executePatrolBehavior() (turnLeft bool, turnRight bool) <span class="cov0" title="0">{
        if ai.random.Float64() &lt; 0.2 </span><span class="cov0" title="0">{
                if ai.random.Float64() &lt; 0.5 </span><span class="cov0" title="0">{
                        return true, false
                }</span>
                <span class="cov0" title="0">return false, true</span>
        }
        <span class="cov0" title="0">return false, false</span>
}

// executeBomberBehavior makes the AI attack enemy planets
func (ai *AIClient) executeBomberBehavior(myShip engine.ShipState) <span class="cov0" title="0">{
        // Find enemy planets to bomb
        target := ai.findEnemyPlanet(myShip.Position)

        thrust := true
        turnLeft := false
        turnRight := false
        beamDown := false

        if target != nil </span><span class="cov0" title="0">{
                // Move towards target planet
                targetVector := target.Position.Sub(myShip.Position)
                distance := targetVector.Length()
                targetAngle := targetVector.Angle()

                angleDiff := targetAngle - myShip.Rotation
                for angleDiff &gt; math.Pi </span><span class="cov0" title="0">{
                        angleDiff -= 2 * math.Pi
                }</span>
                <span class="cov0" title="0">for angleDiff &lt; -math.Pi </span><span class="cov0" title="0">{
                        angleDiff += 2 * math.Pi
                }</span>

                <span class="cov0" title="0">if math.Abs(angleDiff) &gt; 0.1 </span><span class="cov0" title="0">{
                        if angleDiff &gt; 0 </span><span class="cov0" title="0">{
                                turnLeft = true
                        }</span> else<span class="cov0" title="0"> {
                                turnRight = true
                        }</span>
                }

                // If close to planet, beam down armies (bomb)
                <span class="cov0" title="0">if distance &lt; 100 &amp;&amp; myShip.Armies &gt; 0 </span><span class="cov0" title="0">{
                        beamDown = true
                }</span>
        }

        <span class="cov0" title="0">ai.client.SendInput(thrust, turnLeft, turnRight, -1, beamDown, false, 1, 0)</span>
}

// Helper functions for AI decision making

func (ai *AIClient) findNearestEnemyShip(myPos physics.Vector2D) *engine.ShipState <span class="cov0" title="0">{
        var nearest *engine.ShipState
        var nearestDistance float64 = math.Inf(1)

        for _, ship := range ai.lastGameState.Ships </span><span class="cov0" title="0">{
                if ship.TeamID != ai.teamID </span><span class="cov0" title="0">{
                        distance := ship.Position.Distance(myPos)
                        if distance &lt; nearestDistance </span><span class="cov0" title="0">{
                                nearest = &amp;ship
                                nearestDistance = distance
                        }</span>
                }
        }

        <span class="cov0" title="0">return nearest</span>
}

func (ai *AIClient) findHomePlanet() *engine.PlanetState <span class="cov0" title="0">{
        // Look for planets owned by our team - use planet names to identify home planets
        for _, planet := range ai.lastGameState.Planets </span><span class="cov0" title="0">{
                if planet.TeamID == ai.teamID </span><span class="cov0" title="0">{
                        // Common home planet names
                        if planet.Name == "Earth" || planet.Name == "Qo'noS" ||
                                planet.Name == "Romulus" || planet.Name == "Cardassia" </span><span class="cov0" title="0">{
                                return &amp;planet
                        }</span>
                }
        }

        // If no home planet found by name, return any planet owned by our team
        <span class="cov0" title="0">for _, planet := range ai.lastGameState.Planets </span><span class="cov0" title="0">{
                if planet.TeamID == ai.teamID </span><span class="cov0" title="0">{
                        return &amp;planet
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (ai *AIClient) findEnemyPlanet(myPos physics.Vector2D) *engine.PlanetState <span class="cov0" title="0">{
        var target *engine.PlanetState
        var nearestDistance float64 = math.Inf(1)

        for _, planet := range ai.lastGameState.Planets </span><span class="cov0" title="0">{
                if planet.TeamID != ai.teamID &amp;&amp; planet.TeamID &gt;= 0 </span><span class="cov0" title="0">{
                        distance := planet.Position.Distance(myPos)
                        if distance &lt; nearestDistance </span><span class="cov0" title="0">{
                                target = &amp;planet
                                nearestDistance = distance
                        }</span>
                }
        }

        <span class="cov0" title="0">return target</span>
}

func getBehaviorDescription(behavior AIBehavior) string <span class="cov0" title="0">{
        switch behavior </span>{
        case BehaviorExplorer:<span class="cov0" title="0">
                return "Explores the galaxy peacefully"</span>
        case BehaviorAggressor:<span class="cov0" title="0">
                return "Seeks out and attacks enemy ships"</span>
        case BehaviorDefender:<span class="cov0" title="0">
                return "Defends team's home planets"</span>
        case BehaviorBomber:<span class="cov0" title="0">
                return "Attacks enemy planets"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// examples/simple_server/main.go
// Simple server example demonstrating basic Netrek server setup
package main

import (
        "flag"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/opd-ai/go-netrek/pkg/config"
        "github.com/opd-ai/go-netrek/pkg/engine"
        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/network"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        port := flag.String("port", "4566", "Server port")
        maxClients := flag.Int("max-clients", 8, "Maximum number of clients")
        flag.Parse()

        log.Println("Starting Simple Netrek Server...")

        // Create a simple game configuration
        gameConfig := createSimpleGameConfig(*port, *maxClients)

        // Create game engine
        game := engine.NewGame(gameConfig)
        log.Printf("Game created with %d teams and %d planets", len(gameConfig.Teams), len(gameConfig.Planets))

        // Create and start server
        server := network.NewGameServer(game, gameConfig.MaxPlayers)
        serverAddr := "localhost:" + *port

        log.Printf("Starting server on %s", serverAddr)
        if err := server.Start(serverAddr); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>

        // Start game loop in background
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Println("Starting game loop...")
                for game.Running </span><span class="cov0" title="0">{
                        game.Update()
                        time.Sleep(time.Second / 60) // 60 FPS
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("Server is ready! Connect with:")
        log.Printf("  go run examples/ai_client/main.go -server=localhost:%s -name=Player1 -team=0", *port)
        log.Printf("  go run examples/ai_client/main.go -server=localhost:%s -name=Player2 -team=1", *port)

        // Handle graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down server...")
        server.Stop()
        game.Stop()
        log.Println("Server stopped.")</span>
}

// createSimpleGameConfig creates a basic game configuration suitable for testing
func createSimpleGameConfig(port string, maxClients int) *config.GameConfig <span class="cov0" title="0">{
        return &amp;config.GameConfig{
                WorldSize:  8000,
                MaxPlayers: maxClients,
                Teams: []config.TeamConfig{
                        {
                                Name:         "Federation",
                                Color:        "#0066FF",
                                MaxShips:     4,
                                StartingShip: "Scout",
                        },
                        {
                                Name:         "Klingons",
                                Color:        "#FF6600",
                                MaxShips:     4,
                                StartingShip: "Scout",
                        },
                },
                Planets: []config.PlanetConfig{
                        {
                                Name:          "Earth",
                                X:             -2000,
                                Y:             0,
                                Type:          entity.Homeworld,
                                HomeWorld:     true,
                                TeamID:        0,
                                InitialArmies: 25,
                        },
                        {
                                Name:          "Qo'noS",
                                X:             2000,
                                Y:             0,
                                Type:          entity.Homeworld,
                                HomeWorld:     true,
                                TeamID:        1,
                                InitialArmies: 25,
                        },
                        {
                                Name:          "Neutral Station",
                                X:             0,
                                Y:             1500,
                                Type:          entity.Industrial,
                                HomeWorld:     false,
                                TeamID:        -1, // Neutral
                                InitialArmies: 15,
                        },
                        {
                                Name:          "Mining Colony",
                                X:             0,
                                Y:             -1500,
                                Type:          entity.Agricultural,
                                HomeWorld:     false,
                                TeamID:        -1, // Neutral
                                InitialArmies: 10,
                        },
                },
                PhysicsConfig: config.PhysicsConfig{
                        Gravity:         0,
                        Friction:        0.05,
                        CollisionDamage: 15,
                },
                NetworkConfig: config.NetworkConfig{
                        UpdateRate:      20,
                        TicksPerState:   2,
                        UsePartialState: true,
                        ServerPort:      4566,
                        ServerAddress:   "localhost:" + port,
                },
                GameRules: config.GameRules{
                        WinCondition:   "conquest",
                        TimeLimit:      900, // 15 minutes
                        MaxScore:       50,
                        RespawnDelay:   3,
                        FriendlyFire:   false,
                        StartingArmies: 0,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// pkg/config/config.go
package config

import (
        "encoding/json"
        "fmt"
        "os"

        "github.com/opd-ai/go-netrek/pkg/entity"
)

// ShipTypeConfig allows defining custom ship types and stats in config
// Keyed by name (e.g. "Scout", "Destroyer")
type ShipTypeConfig struct {
        Name         string  `json:"name"`
        MaxHull      int     `json:"maxHull"`
        MaxShields   int     `json:"maxShields"`
        MaxFuel      int     `json:"maxFuel"`
        Acceleration float64 `json:"acceleration"`
        TurnRate     float64 `json:"turnRate"`
        MaxSpeed     float64 `json:"maxSpeed"`
        WeaponSlots  int     `json:"weaponSlots"`
        MaxArmies    int     `json:"maxArmies"`
}

// GameConfig contains configuration for a Netrek game
type GameConfig struct {
        WorldSize     float64                   `json:"worldSize"`
        MaxPlayers    int                       `json:"maxPlayers"`
        Teams         []TeamConfig              `json:"teams"`
        Planets       []PlanetConfig            `json:"planets"`
        PhysicsConfig PhysicsConfig             `json:"physics"`
        NetworkConfig NetworkConfig             `json:"network"`
        GameRules     GameRules                 `json:"gameRules"`
        ShipTypes     map[string]ShipTypeConfig `json:"shipTypes"`
}

// TeamConfig contains configuration for a team
type TeamConfig struct {
        Name         string `json:"name"`
        Color        string `json:"color"`
        MaxShips     int    `json:"maxShips"`
        StartingShip string `json:"startingShip"`
}

// PlanetConfig contains configuration for a planet
type PlanetConfig struct {
        Name          string            `json:"name"`
        X             float64           `json:"x"`
        Y             float64           `json:"y"`
        Type          entity.PlanetType `json:"type"`
        HomeWorld     bool              `json:"homeWorld"`
        TeamID        int               `json:"teamID"`
        InitialArmies int               `json:"initialArmies"`
}

// PhysicsConfig contains physics-related configuration
type PhysicsConfig struct {
        Gravity         float64 `json:"gravity"`
        Friction        float64 `json:"friction"`
        CollisionDamage float64 `json:"collisionDamage"`
}

// NetworkConfig contains network-related configuration
type NetworkConfig struct {
        UpdateRate      int    `json:"updateRate"`
        TicksPerState   int    `json:"ticksPerState"`
        UsePartialState bool   `json:"usePartialState"`
        ServerPort      int    `json:"serverPort"`
        ServerAddress   string `json:"serverAddress"`
}

// GameRules contains game rules configuration
type GameRules struct {
        WinCondition   string `json:"winCondition"`
        TimeLimit      int    `json:"timeLimit"`
        MaxScore       int    `json:"maxScore"`
        RespawnDelay   int    `json:"respawnDelay"`
        FriendlyFire   bool   `json:"friendlyFire"`
        StartingArmies int    `json:"startingArmies"`
}

// LoadConfig loads a configuration from a file
func LoadConfig(path string) (*GameConfig, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config GameConfig
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Convert ShipTypes to entity.ShipStats and inject
        <span class="cov8" title="1">if len(config.ShipTypes) &gt; 0 </span><span class="cov8" title="1">{
                stats := make(map[string]entity.ShipStats)
                for name, st := range config.ShipTypes </span><span class="cov8" title="1">{
                        stats[name] = entity.ShipStats{
                                MaxHull:      st.MaxHull,
                                MaxShields:   st.MaxShields,
                                MaxFuel:      st.MaxFuel,
                                Acceleration: st.Acceleration,
                                TurnRate:     st.TurnRate,
                                MaxSpeed:     st.MaxSpeed,
                                WeaponSlots:  st.WeaponSlots,
                                MaxArmies:    st.MaxArmies,
                        }
                }</span>
                <span class="cov8" title="1">entity.SetShipTypeStats(stats)</span>
        }

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// SaveConfig saves a configuration to a file
func SaveConfig(config *GameConfig, path string) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0o644); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DefaultConfig returns a default game configuration
func DefaultConfig() *GameConfig <span class="cov8" title="1">{
        return &amp;GameConfig{
                WorldSize:     10000,
                MaxPlayers:    16,
                Teams:         createDefaultTeams(),
                Planets:       createDefaultPlanets(),
                PhysicsConfig: createDefaultPhysicsConfig(),
                NetworkConfig: createDefaultNetworkConfig(),
                GameRules:     createDefaultGameRules(),
                ShipTypes:     createDefaultShipTypes(),
        }
}</span>

// createDefaultTeams creates the default team configurations for a new game.
func createDefaultTeams() []TeamConfig <span class="cov8" title="1">{
        return []TeamConfig{
                {
                        Name:         "Federation",
                        Color:        "#0000FF",
                        MaxShips:     8,
                        StartingShip: "Scout",
                },
                {
                        Name:         "Romulans",
                        Color:        "#00FF00",
                        MaxShips:     8,
                        StartingShip: "Scout",
                },
        }
}</span>

// createDefaultPlanets creates the default planet configurations for a new game.
func createDefaultPlanets() []PlanetConfig <span class="cov8" title="1">{
        return []PlanetConfig{
                {
                        Name:          "Earth",
                        X:             -4000,
                        Y:             0,
                        Type:          entity.Homeworld,
                        HomeWorld:     true,
                        TeamID:        0,
                        InitialArmies: 30,
                },
                {
                        Name:          "Romulus",
                        X:             4000,
                        Y:             0,
                        Type:          entity.Homeworld,
                        HomeWorld:     true,
                        TeamID:        1,
                        InitialArmies: 30,
                },
                // Additional planets would be defined here
        }
}</span>

// createDefaultPhysicsConfig creates the default physics configuration for a new game.
func createDefaultPhysicsConfig() PhysicsConfig <span class="cov8" title="1">{
        return PhysicsConfig{
                Gravity:         0,
                Friction:        0.1,
                CollisionDamage: 20,
        }
}</span>

// createDefaultNetworkConfig creates the default network configuration for a new game.
func createDefaultNetworkConfig() NetworkConfig <span class="cov8" title="1">{
        return NetworkConfig{
                UpdateRate:      20,
                TicksPerState:   3,
                UsePartialState: true,
                ServerPort:      4566,
                ServerAddress:   "localhost:4566",
        }
}</span>

// createDefaultGameRules creates the default game rules configuration for a new game.
func createDefaultGameRules() GameRules <span class="cov8" title="1">{
        return GameRules{
                WinCondition:   "conquest",
                TimeLimit:      1800,
                MaxScore:       100,
                RespawnDelay:   5,
                FriendlyFire:   false,
                StartingArmies: 0,
        }
}</span>

// createDefaultShipTypes creates the default ship type configurations for a new game.
func createDefaultShipTypes() map[string]ShipTypeConfig <span class="cov8" title="1">{
        return map[string]ShipTypeConfig{
                "Scout": {
                        Name:         "Scout",
                        MaxHull:      100,
                        MaxShields:   100,
                        MaxFuel:      1000,
                        Acceleration: 200,
                        TurnRate:     3.0,
                        MaxSpeed:     300,
                        WeaponSlots:  2,
                        MaxArmies:    2,
                },
                "Destroyer": {
                        Name:         "Destroyer",
                        MaxHull:      150,
                        MaxShields:   150,
                        MaxFuel:      1200,
                        Acceleration: 150,
                        TurnRate:     2.5,
                        MaxSpeed:     250,
                        WeaponSlots:  3,
                        MaxArmies:    5,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// pkg/engine/game.go
package engine

import (
        "errors"
        "math"
        "math/rand/v2"
        "sync"
        "time"

        "github.com/opd-ai/go-netrek/pkg/config"
        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/event"
        "github.com/opd-ai/go-netrek/pkg/physics"
)

// pkg/engine/game.go
type GameStatus int

const (
        GameStatusWaiting GameStatus = iota
        GameStatusActive
        GameStatusEnded
)

// WinCondition defines an interface for custom win condition logic
// Returns (winningTeamID, true) if a winner is found, else (-1, false)
type WinCondition interface {
        CheckWinner(game *Game) (int, bool)
}

// Game represents the core game state and logic
type Game struct {
        Config       *config.GameConfig
        Ships        map[entity.ID]*entity.Ship
        Planets      map[entity.ID]*entity.Planet
        Projectiles  map[entity.ID]*entity.Projectile
        Teams        map[int]*Team
        EntityLock   sync.RWMutex
        Running      bool
        TimeStep     float64 // Seconds per game tick
        CurrentTick  uint64
        LastUpdate   time.Time
        EventBus     *event.Bus
        SpatialIndex *physics.QuadTree
        Status       GameStatus
        WinningTeam  int // Team ID of winner, -1 if no winner
        EndTime      time.Time
        StartTime    time.Time
        ElapsedTime  float64 // seconds

        CustomWinCondition WinCondition // Optional custom win condition
}

// Team represents a player team in the game
type Team struct {
        ID          int
        Name        string
        Color       string
        Score       int
        ShipCount   int
        PlanetCount int
        Players     map[entity.ID]*Player
}

// Player represents a connected player
type Player struct {
        ID        entity.ID
        Name      string
        TeamID    int
        ShipID    entity.ID
        Connected bool
        Score     int
        Kills     int
        Deaths    int
        Bombs     int
        Captures  int
}

// NewGame creates a new game with the specified configuration
func NewGame(config *config.GameConfig) *Game <span class="cov8" title="1">{
        game := &amp;Game{
                Config:      config,
                Ships:       make(map[entity.ID]*entity.Ship),
                Planets:     make(map[entity.ID]*entity.Planet),
                Projectiles: make(map[entity.ID]*entity.Projectile),
                Teams:       make(map[int]*Team),
                TimeStep:    1.0 / 60.0, // 60 FPS
                CurrentTick: 0,
                LastUpdate:  time.Now(),
                EventBus:    event.NewEventBus(),
        }

        // Initialize game components
        game.initSpatialIndex()
        game.initTeams()
        game.initPlanets()
        game.registerEventHandlers()

        return game
}</span>

// initSpatialIndex creates the spatial index for collision detection.
func (g *Game) initSpatialIndex() <span class="cov8" title="1">{
        worldSize := g.Config.WorldSize
        g.SpatialIndex = physics.NewQuadTree(
                physics.Rect{
                        Center: physics.Vector2D{X: 0, Y: 0},
                        Width:  worldSize,
                        Height: worldSize,
                },
                10, // Maximum entities per quad before subdivision
        )
}</span>

// initTeams initializes the teams based on the game configuration.
func (g *Game) initTeams() <span class="cov8" title="1">{
        for i, teamConfig := range g.Config.Teams </span><span class="cov8" title="1">{
                team := &amp;Team{
                        ID:      i,
                        Name:    teamConfig.Name,
                        Color:   teamConfig.Color,
                        Players: make(map[entity.ID]*Player),
                }
                g.Teams[i] = team
        }</span>
}

// initPlanets initializes the planets based on the game configuration.
func (g *Game) initPlanets() <span class="cov8" title="1">{
        for _, planetConfig := range g.Config.Planets </span><span class="cov8" title="1">{
                planet := entity.NewPlanet(
                        entity.GenerateID(),
                        planetConfig.Name,
                        physics.Vector2D{X: planetConfig.X, Y: planetConfig.Y},
                        planetConfig.Type,
                )

                if planetConfig.HomeWorld </span><span class="cov8" title="1">{
                        planet.TeamID = planetConfig.TeamID
                        planet.Armies = planetConfig.InitialArmies

                        // Update team planet count
                        if team, ok := g.Teams[planetConfig.TeamID]; ok </span><span class="cov8" title="1">{
                                team.PlanetCount++
                        }</span>
                }

                <span class="cov8" title="1">g.Planets[planet.GetID()] = planet</span>
        }
}

// Start begins the game update loop
func (g *Game) Start() <span class="cov8" title="1">{
        g.Running = true
        g.Status = GameStatusActive
        g.StartTime = time.Now()
        g.LastUpdate = time.Now()
        g.EventBus.Publish(&amp;event.BaseEvent{
                EventType: event.GameStarted,
                Source:    g,
        })
}</span>

// Stop halts the game update loop
func (g *Game) Stop() <span class="cov8" title="1">{
        g.Running = false
        g.EventBus.Publish(&amp;event.BaseEvent{
                EventType: event.GameEnded,
                Source:    g,
        })
}</span>

// Update advances the game state by one tick
func (g *Game) Update() <span class="cov8" title="1">{
        g.checkTimeLimit()
        deltaTime := g.calculateDeltaTime()

        g.EntityLock.Lock()
        defer g.EntityLock.Unlock()

        g.updateGameState(deltaTime)
}</span>

// checkTimeLimit checks if the game has ended due to the time limit.
func (g *Game) checkTimeLimit() <span class="cov8" title="1">{
        if g.Status == GameStatusActive </span><span class="cov8" title="1">{
                g.ElapsedTime = time.Since(g.StartTime).Seconds()
                if g.Config.GameRules.TimeLimit &gt; 0 &amp;&amp;
                        g.ElapsedTime &gt;= float64(g.Config.GameRules.TimeLimit) </span><span class="cov8" title="1">{
                        g.endGame()
                }</span>
        }
}

// calculateDeltaTime calculates the time since the last update and caps it.
func (g *Game) calculateDeltaTime() float64 <span class="cov8" title="1">{
        now := time.Now()
        deltaTime := now.Sub(g.LastUpdate).Seconds()
        g.LastUpdate = now

        // Cap delta time to prevent physics issues
        if deltaTime &gt; 0.1 </span><span class="cov0" title="0">{
                deltaTime = 0.1
        }</span>
        <span class="cov8" title="1">return deltaTime</span>
}

// updateGameState updates all entities, processes collisions, and cleans up.
func (g *Game) updateGameState(deltaTime float64) <span class="cov8" title="1">{
        g.updateEntities(deltaTime)
        g.processCollisions()
        g.cleanupInactiveEntities()
        g.CurrentTick++
}</span>

// updateEntities updates all entities and the spatial index.
func (g *Game) updateEntities(deltaTime float64) <span class="cov8" title="1">{
        g.prepareSpatialIndex()

        // Update all entities
        g.updateShips(deltaTime)
        g.updateProjectiles(deltaTime)
        g.updatePlanets(deltaTime)

        g.populateSpatialIndex()
}</span>

// prepareSpatialIndex clears the spatial index for the new frame or initializes it.
func (g *Game) prepareSpatialIndex() <span class="cov8" title="1">{
        if g.SpatialIndex == nil </span><span class="cov0" title="0">{
                g.SpatialIndex = physics.NewQuadTree(
                        physics.Rect{
                                Center: physics.Vector2D{X: 0, Y: 0},
                                Width:  g.Config.WorldSize,
                                Height: g.Config.WorldSize,
                        },
                        10, // Maximum entities per quad before subdivision
                )
        }</span> else<span class="cov8" title="1"> {
                g.SpatialIndex.Clear()
        }</span>
}

// populateSpatialIndex adds all active entities to the spatial index.
func (g *Game) populateSpatialIndex() <span class="cov8" title="1">{
        for _, ship := range g.Ships </span><span class="cov8" title="1">{
                if ship.Active </span><span class="cov8" title="1">{
                        g.SpatialIndex.Insert(ship.Position, ship)
                }</span>
        }

        <span class="cov8" title="1">for _, projectile := range g.Projectiles </span><span class="cov0" title="0">{
                if projectile.Active </span><span class="cov0" title="0">{
                        g.SpatialIndex.Insert(projectile.Position, projectile)
                }</span>
        }

        <span class="cov8" title="1">for _, planet := range g.Planets </span><span class="cov8" title="1">{
                g.SpatialIndex.Insert(planet.Position, planet)
        }</span>
}

// processCollisions checks for and resolves collisions between entities.
func (g *Game) processCollisions() <span class="cov8" title="1">{
        g.detectCollisions()
}</span>

// updateShips updates all ships
func (g *Game) updateShips(deltaTime float64) <span class="cov8" title="1">{
        for _, ship := range g.Ships </span><span class="cov8" title="1">{
                if ship.Active </span><span class="cov8" title="1">{
                        ship.Update(deltaTime)

                        // Wrap ships around the world boundaries
                        g.wrapEntityPosition(ship)
                }</span>
        }
}

// updateProjectiles updates all projectiles
func (g *Game) updateProjectiles(deltaTime float64) <span class="cov8" title="1">{
        for _, proj := range g.Projectiles </span><span class="cov0" title="0">{
                if proj.Active </span><span class="cov0" title="0">{
                        proj.Update(deltaTime)

                        // Wrap projectiles around the world boundaries
                        g.wrapEntityPosition(proj)
                }</span>
        }
}

// updatePlanets updates all planets
func (g *Game) updatePlanets(deltaTime float64) <span class="cov8" title="1">{
        for _, planet := range g.Planets </span><span class="cov8" title="1">{
                planet.Update(deltaTime)
        }</span>
}

// wrapEntityPosition wraps an entity's position around the world boundaries
func (g *Game) wrapEntityPosition(e interface{}) <span class="cov8" title="1">{
        pos, radius, ok := g.extractEntityPositionData(e)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">g.wrapCoordinatesAroundWorld(pos)
        g.resolvePositionCollisions(e, pos, radius)</span>
}

// extractEntityPositionData extracts position and radius from an entity interface.
// It returns the position vector, radius, and whether the extraction was successful.
func (g *Game) extractEntityPositionData(e interface{}) (*physics.Vector2D, float64, bool) <span class="cov8" title="1">{
        switch entity := e.(type) </span>{
        case *entity.Ship:<span class="cov8" title="1">
                return &amp;entity.Position, entity.Collider.Radius, true</span>
        case *entity.Projectile:<span class="cov0" title="0">
                return &amp;entity.Position, entity.Collider.Radius, true</span>
        default:<span class="cov0" title="0">
                return nil, 0, false</span>
        }
}

// wrapCoordinatesAroundWorld wraps the given position coordinates around world boundaries.
// It modifies the position in-place to ensure it stays within the world bounds.
func (g *Game) wrapCoordinatesAroundWorld(pos *physics.Vector2D) <span class="cov8" title="1">{
        worldSize := g.Config.WorldSize
        halfWorld := worldSize / 2

        // Wrap X coordinate
        if pos.X &gt; halfWorld </span><span class="cov8" title="1">{
                pos.X -= worldSize
        }</span> else<span class="cov8" title="1"> if pos.X &lt; -halfWorld </span><span class="cov0" title="0">{
                pos.X += worldSize
        }</span>

        // Wrap Y coordinate
        <span class="cov8" title="1">if pos.Y &gt; halfWorld </span><span class="cov8" title="1">{
                pos.Y -= worldSize
        }</span> else<span class="cov8" title="1"> if pos.Y &lt; -halfWorld </span><span class="cov0" title="0">{
                pos.Y += worldSize
        }</span>
}

// resolvePositionCollisions nudges the entity away from any overlapping ships.
// It prevents entities from overlapping after position wrapping by adjusting their position.
func (g *Game) resolvePositionCollisions(e interface{}, pos *physics.Vector2D, radius float64) <span class="cov8" title="1">{
        for _, other := range g.Ships </span><span class="cov8" title="1">{
                if other == e || !other.Active </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">dist := pos.Distance(other.Position)
                minDist := radius + other.Collider.Radius
                if dist &lt; minDist &amp;&amp; dist &gt; 0 </span><span class="cov8" title="1">{
                        // Nudge along the vector between centers
                        delta := pos.Sub(other.Position).Normalize().Scale(minDist - dist + 0.1)
                        *pos = pos.Add(delta)
                }</span>
        }
}

// detectCollisions checks for and resolves collisions between entities
func (g *Game) detectCollisions() <span class="cov8" title="1">{
        g.processShipProjectileCollisions()
        g.processShipPlanetCollisions()
        g.processProjectilePlanetCollisions()
}</span>

// processShipProjectileCollisions handles collisions between ships and projectiles.
func (g *Game) processShipProjectileCollisions() <span class="cov8" title="1">{
        for _, ship := range g.Ships </span><span class="cov8" title="1">{
                g.checkCollisionsForShip(ship)
        }</span>
}

// checkCollisionsForShip finds and handles collisions for a single ship.
func (g *Game) checkCollisionsForShip(ship *entity.Ship) <span class="cov8" title="1">{
        if !ship.Active </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">shipArea := physics.Rect{
                Center: ship.Position,
                Width:  ship.Collider.Radius * 2,
                Height: ship.Collider.Radius * 2,
        }
        potentialCollisions := g.SpatialIndex.Query(shipArea)
        for _, other := range potentialCollisions </span><span class="cov8" title="1">{
                if projectile, ok := other.(*entity.Projectile); ok </span><span class="cov0" title="0">{
                        g.handleShipProjectileCollision(ship, projectile)
                }</span>
        }
}

// handleShipProjectileCollision checks and resolves a collision between a ship and a projectile.
func (g *Game) handleShipProjectileCollision(ship *entity.Ship, projectile *entity.Projectile) <span class="cov0" title="0">{
        if !g.canShipAndProjectileCollide(ship, projectile) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if ship.GetCollider().Collides(projectile.GetCollider()) </span><span class="cov0" title="0">{
                g.processShipDamage(ship, projectile)
        }</span>
}

// canShipAndProjectileCollide determines if a collision check is necessary.
func (g *Game) canShipAndProjectileCollide(ship *entity.Ship, projectile *entity.Projectile) bool <span class="cov0" title="0">{
        return projectile.Active &amp;&amp; projectile.TeamID != ship.TeamID
}</span>

// processShipDamage handles the consequences of a ship taking damage from a projectile.
func (g *Game) processShipDamage(ship *entity.Ship, projectile *entity.Projectile) <span class="cov0" title="0">{
        destroyed := ship.TakeDamage(projectile.Damage)
        projectile.Active = false

        g.EventBus.Publish(event.NewCollisionEvent(
                g,
                uint64(ship.ID),
                uint64(projectile.ID),
        ))

        if destroyed </span><span class="cov0" title="0">{
                g.handleShipDestruction(ship, projectile)
        }</span>
}

// handleShipDestruction manages the game state changes when a ship is destroyed.
func (g *Game) handleShipDestruction(ship *entity.Ship, projectile *entity.Projectile) <span class="cov0" title="0">{
        ship.Active = false
        g.updatePlayerStatsOnShipDestruction(ship, projectile)
        g.EventBus.Publish(event.NewShipEvent(
                event.ShipDestroyed,
                g,
                uint64(ship.ID),
                ship.TeamID,
        ))
}</span>

// updatePlayerStatsOnShipDestruction updates player stats when a ship is destroyed by a projectile.
func (g *Game) updatePlayerStatsOnShipDestruction(ship *entity.Ship, projectile *entity.Projectile) <span class="cov0" title="0">{
        if player, ok := g.findPlayerByShipID(projectile.OwnerID); ok </span><span class="cov0" title="0">{
                player.Kills++
                player.Score += 10 // Points for kill
        }</span>
        <span class="cov0" title="0">if player, ok := g.findPlayerByShipID(ship.ID); ok </span><span class="cov0" title="0">{
                player.Deaths++
        }</span>
}

// processShipPlanetCollisions handles ship-planet proximity and collision responses.
func (g *Game) processShipPlanetCollisions() <span class="cov8" title="1">{
        for _, ship := range g.Ships </span><span class="cov8" title="1">{
                g.checkInteractionsForShip(ship)
        }</span>
}

// checkInteractionsForShip finds and handles interactions for a single ship.
func (g *Game) checkInteractionsForShip(ship *entity.Ship) <span class="cov8" title="1">{
        if !ship.Active </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">shipArea := physics.Rect{
                Center: ship.Position,
                Width:  ship.Collider.Radius * 2,
                Height: ship.Collider.Radius * 2,
        }
        potentialCollisions := g.SpatialIndex.Query(shipArea)
        for _, other := range potentialCollisions </span><span class="cov8" title="1">{
                if planet, ok := other.(*entity.Planet); ok </span><span class="cov0" title="0">{
                        g.handleShipPlanetInteraction(ship, planet)
                }</span>
        }
}

// handleShipPlanetInteraction manages ship-planet proximity and collision response.
func (g *Game) handleShipPlanetInteraction(ship *entity.Ship, planet *entity.Planet) <span class="cov0" title="0">{
        distance := ship.Position.Distance(planet.Position)
        if distance &lt; ship.Collider.Radius+planet.Collider.Radius+10 </span><span class="cov0" title="0">{
                if distance &lt; ship.Collider.Radius+planet.Collider.Radius </span><span class="cov0" title="0">{
                        pushDir := ship.Position.Sub(planet.Position).Normalize()
                        pushDistance := (ship.Collider.Radius + planet.Collider.Radius) - distance
                        ship.Position = ship.Position.Add(pushDir.Scale(pushDistance + 1))
                        ship.Velocity = ship.Velocity.Scale(0.5)
                }</span>
        }
}

// processProjectilePlanetCollisions handles collisions between projectiles and planets.
func (g *Game) processProjectilePlanetCollisions() <span class="cov8" title="1">{
        for _, proj := range g.Projectiles </span><span class="cov0" title="0">{
                g.checkCollisionsForProjectile(proj)
        }</span>
}

// checkCollisionsForProjectile finds and handles collisions for a single projectile.
func (g *Game) checkCollisionsForProjectile(proj *entity.Projectile) <span class="cov0" title="0">{
        if !proj.Active </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">projArea := physics.Rect{
                Center: proj.Position,
                Width:  proj.Collider.Radius * 2,
                Height: proj.Collider.Radius * 2,
        }
        potentialCollisions := g.SpatialIndex.Query(projArea)
        for _, other := range potentialCollisions </span><span class="cov0" title="0">{
                if planet, ok := other.(*entity.Planet); ok </span><span class="cov0" title="0">{
                        g.handleProjectilePlanetCollision(proj, planet)
                }</span>
        }
}

// handleProjectilePlanetCollision checks and resolves a collision between a projectile and a planet.
func (g *Game) handleProjectilePlanetCollision(proj *entity.Projectile, planet *entity.Planet) <span class="cov0" title="0">{
        if proj.Position.Distance(planet.Position) &lt; proj.Collider.Radius+planet.Collider.Radius </span><span class="cov0" title="0">{
                proj.Active = false
                if planet.TeamID &gt;= 0 &amp;&amp; planet.TeamID != proj.TeamID </span><span class="cov0" title="0">{
                        g.processPlanetBombing(proj, planet)
                }</span>
        }
}

// processPlanetBombing handles the logic when a projectile bombs a planet.
func (g *Game) processPlanetBombing(proj *entity.Projectile, planet *entity.Planet) <span class="cov0" title="0">{
        armiesKilled := planet.Bomb(proj.Damage / 2) // Reduced damage for bombing
        if player, ok := g.findPlayerByShipID(proj.OwnerID); ok </span><span class="cov0" title="0">{
                player.Bombs += armiesKilled
                player.Score += armiesKilled // Points for bombing
        }</span>
        <span class="cov0" title="0">if planet.TeamID == -1 </span><span class="cov0" title="0">{ // Planet was just neutralized
                g.handlePlanetNeutralization(planet)
        }</span>
}

// handlePlanetNeutralization updates game state when a planet becomes neutral.
func (g *Game) handlePlanetNeutralization(planet *entity.Planet) <span class="cov0" title="0">{
        if team, ok := g.Teams[planet.TeamID]; ok </span><span class="cov0" title="0">{
                team.PlanetCount--
        }</span>
        <span class="cov0" title="0">g.EventBus.Publish(event.NewPlanetEvent(
                event.PlanetCaptured, // Or a new "PlanetNeutralized" event type
                g,
                uint64(planet.ID),
                -1,            // New team is neutral
                planet.TeamID, // Old team ID
        ))</span>
}

// findPlayerByShipID finds a player by their ship ID
func (g *Game) findPlayerByShipID(shipID entity.ID) (*Player, bool) <span class="cov0" title="0">{
        for _, team := range g.Teams </span><span class="cov0" title="0">{
                for _, player := range team.Players </span><span class="cov0" title="0">{
                        if player.ShipID == shipID </span><span class="cov0" title="0">{
                                return player, true
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, false</span>
}

// cleanupInactiveEntities removes inactive entities
func (g *Game) cleanupInactiveEntities() <span class="cov8" title="1">{
        // Remove inactive projectiles
        for id, proj := range g.Projectiles </span><span class="cov8" title="1">{
                if !proj.Active </span><span class="cov8" title="1">{
                        delete(g.Projectiles, id)
                }</span>
        }

        // Ships are respawned, not deleted
}

// AddPlayer adds a new player to the game
func (g *Game) AddPlayer(name string, teamID int) (entity.ID, error) <span class="cov8" title="1">{
        g.EntityLock.Lock()
        defer g.EntityLock.Unlock()

        team, err := g.validateTeam(teamID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">player := g.createAndAddPlayer(name, team)
        ship := g.createAndAddShip(player)
        g.assignShipToPlayer(player, ship, team)

        g.publishPlayerAndShipCreationEvents(player, ship)

        return player.ID, nil</span>
}

// validateTeam checks if the teamID is valid and returns the team.
func (g *Game) validateTeam(teamID int) (*Team, error) <span class="cov8" title="1">{
        team, ok := g.Teams[teamID]
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.New("invalid team")
        }</span>
        <span class="cov8" title="1">return team, nil</span>
}

// createAndAddPlayer creates a new player and adds it to the team.
func (g *Game) createAndAddPlayer(name string, team *Team) *Player <span class="cov8" title="1">{
        player := g.createPlayer(name, team.ID)
        team.Players[player.ID] = player
        return player
}</span>

// createAndAddShip creates a new ship and adds it to the game.
func (g *Game) createAndAddShip(player *Player) *entity.Ship <span class="cov8" title="1">{
        ship := g.createShipForPlayer(player)
        g.Ships[ship.ID] = ship
        return ship
}</span>

// assignShipToPlayer assigns a ship to a player and updates team stats.
func (g *Game) assignShipToPlayer(player *Player, ship *entity.Ship, team *Team) <span class="cov8" title="1">{
        player.ShipID = ship.ID
        team.ShipCount++
}</span>

// createPlayer creates a new player entity.
func (g *Game) createPlayer(name string, teamID int) *Player <span class="cov8" title="1">{
        return &amp;Player{
                ID:        entity.GenerateID(),
                Name:      name,
                TeamID:    teamID,
                Connected: true,
        }
}</span>

// createShipForPlayer creates a new ship for a given player.
func (g *Game) createShipForPlayer(player *Player) *entity.Ship <span class="cov8" title="1">{
        spawnPoint := g.findSpawnPoint(player.TeamID)
        shipClass := entity.Scout
        if player.TeamID &lt; len(g.Config.Teams) </span><span class="cov8" title="1">{
                shipClass = entity.ShipClassFromString(g.Config.Teams[player.TeamID].StartingShip)
        }</span>
        <span class="cov8" title="1">return entity.NewShip(
                entity.GenerateID(),
                shipClass,
                player.TeamID,
                spawnPoint,
        )</span>
}

// publishPlayerAndShipCreationEvents publishes events for player joining and ship creation.
func (g *Game) publishPlayerAndShipCreationEvents(player *Player, ship *entity.Ship) <span class="cov8" title="1">{
        g.EventBus.Publish(&amp;event.BaseEvent{
                EventType: event.PlayerJoined,
                Source:    player,
        })
        g.EventBus.Publish(event.NewShipEvent(
                event.ShipCreated,
                g,
                uint64(ship.ID),
                ship.TeamID,
        ))
}</span>

// RemovePlayer removes a player from the game
func (g *Game) RemovePlayer(playerID entity.ID) error <span class="cov8" title="1">{
        g.EntityLock.Lock()
        defer g.EntityLock.Unlock()

        player, team, err := g.findPlayerAndTeam(playerID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">g.deactivatePlayerShip(player)
        g.removePlayerFromTeam(player, team)
        g.publishPlayerLeftEvent(player)

        return nil</span>
}

// findPlayerAndTeam finds a player and their team by player ID.
func (g *Game) findPlayerAndTeam(playerID entity.ID) (*Player, *Team, error) <span class="cov8" title="1">{
        for _, t := range g.Teams </span><span class="cov8" title="1">{
                if p, ok := t.Players[playerID]; ok </span><span class="cov8" title="1">{
                        return p, t, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil, errors.New("player not found")</span>
}

// deactivatePlayerShip marks the player's ship as inactive and publishes an event.
func (g *Game) deactivatePlayerShip(player *Player) <span class="cov8" title="1">{
        if ship, ok := g.Ships[player.ShipID]; ok </span><span class="cov8" title="1">{
                ship.Active = false

                // Publish ship destroyed event
                g.EventBus.Publish(event.NewShipEvent(
                        event.ShipDestroyed,
                        g,
                        uint64(ship.ID),
                        ship.TeamID,
                ))
        }</span>
}

// removePlayerFromTeam removes a player from their team's records.
func (g *Game) removePlayerFromTeam(player *Player, team *Team) <span class="cov8" title="1">{
        delete(team.Players, player.ID)
        team.ShipCount--
}</span>

// publishPlayerLeftEvent publishes an event indicating a player has left.
func (g *Game) publishPlayerLeftEvent(player *Player) <span class="cov8" title="1">{
        g.EventBus.Publish(&amp;event.BaseEvent{
                EventType: event.PlayerLeft,
                Source:    player,
        })
}</span>

// RespawnShip respawns a player's ship
func (g *Game) RespawnShip(playerID entity.ID) error <span class="cov8" title="1">{
        g.EntityLock.Lock()
        defer g.EntityLock.Unlock()

        player, err := g.findPlayerByID(playerID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Create a new ship
        <span class="cov8" title="1">newShip := g.createShipForPlayer(player)

        // Update player's ship ID and replace ship in game
        oldShipID := player.ShipID
        player.ShipID = newShip.ID
        delete(g.Ships, oldShipID)
        g.Ships[newShip.ID] = newShip

        // Publish ship created event
        g.EventBus.Publish(event.NewShipEvent(
                event.ShipCreated,
                g,
                uint64(newShip.ID),
                player.TeamID,
        ))

        return nil</span>
}

// findPlayerByID finds a player by their ID.
func (g *Game) findPlayerByID(playerID entity.ID) (*Player, error) <span class="cov8" title="1">{
        for _, team := range g.Teams </span><span class="cov8" title="1">{
                if p, ok := team.Players[playerID]; ok </span><span class="cov8" title="1">{
                        return p, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, errors.New("player not found")</span>
}

// BeamArmies beams armies between a ship and a planet
func (g *Game) BeamArmies(shipID, planetID entity.ID, direction string, amount int) (int, error) <span class="cov8" title="1">{
        g.EntityLock.Lock()
        defer g.EntityLock.Unlock()

        ship, planet, err := g.findShipAndPlanet(shipID, planetID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if err := g.validateBeamingPreconditions(ship, planet, direction); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return g.executeBeaming(ship, planet, direction, amount)</span>
}

// findShipAndPlanet retrieves the ship and planet for beaming.
func (g *Game) findShipAndPlanet(shipID, planetID entity.ID) (*entity.Ship, *entity.Planet, error) <span class="cov8" title="1">{
        ship, ok := g.Ships[shipID]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("ship not found")
        }</span>
        <span class="cov8" title="1">planet, ok := g.Planets[planetID]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("planet not found")
        }</span>
        <span class="cov8" title="1">return ship, planet, nil</span>
}

// executeBeaming performs the beaming action based on the direction.
func (g *Game) executeBeaming(ship *entity.Ship, planet *entity.Planet, direction string, amount int) (int, error) <span class="cov8" title="1">{
        switch direction </span>{
        case "down":<span class="cov8" title="1">
                return g.beamArmiesDown(ship, planet, amount)</span>
        case "up":<span class="cov0" title="0">
                return g.beamArmiesUp(ship, planet, amount)</span>
        default:<span class="cov8" title="1">
                return 0, errors.New("invalid beam direction")</span>
        }
}

// validateBeamingPreconditions checks if the ship and planet are in a valid state for beaming.
func (g *Game) validateBeamingPreconditions(ship *entity.Ship, planet *entity.Planet, direction string) error <span class="cov8" title="1">{
        if !ship.Active </span><span class="cov0" title="0">{
                return errors.New("ship is not active")
        }</span>
        <span class="cov8" title="1">if err := g.validateBeamingDistance(ship, planet); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if direction == "up" &amp;&amp; ship.TeamID != planet.TeamID </span><span class="cov0" title="0">{
                return errors.New("cannot beam up from an enemy planet")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateBeamingDistance checks if a ship is close enough to a planet to beam armies.
func (g *Game) validateBeamingDistance(ship *entity.Ship, planet *entity.Planet) error <span class="cov8" title="1">{
        if ship.Position.Distance(planet.Position) &gt; ship.Collider.Radius+planet.Collider.Radius+50 </span><span class="cov0" title="0">{
                return errors.New("ship is too far from planet")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// beamArmiesDown handles beaming armies from a ship to a planet.
func (g *Game) beamArmiesDown(ship *entity.Ship, planet *entity.Planet, amount int) (int, error) <span class="cov8" title="1">{
        if ship.Armies &lt;= 0 </span><span class="cov0" title="0">{
                return 0, errors.New("ship has no armies")
        }</span>

        <span class="cov8" title="1">if amount &gt; ship.Armies </span><span class="cov0" title="0">{
                amount = ship.Armies
        }</span>

        <span class="cov8" title="1">transferred, captured := planet.BeamDownArmies(ship.TeamID, amount)
        ship.Armies -= transferred

        if captured </span><span class="cov0" title="0">{
                g.handlePlanetCapture(ship, planet)
        }</span>

        <span class="cov8" title="1">return transferred, nil</span>
}

// handlePlanetCapture updates game state when a planet is captured.
func (g *Game) handlePlanetCapture(ship *entity.Ship, planet *entity.Planet) <span class="cov0" title="0">{
        oldTeamID := planet.TeamID
        if oldTeamID &gt;= 0 </span><span class="cov0" title="0">{
                if team, ok := g.Teams[oldTeamID]; ok </span><span class="cov0" title="0">{
                        team.PlanetCount--
                }</span>
        }

        <span class="cov0" title="0">planet.TeamID = ship.TeamID
        if team, ok := g.Teams[ship.TeamID]; ok </span><span class="cov0" title="0">{
                team.PlanetCount++
        }</span>

        <span class="cov0" title="0">if player, ok := g.findPlayerByShipID(ship.ID); ok </span><span class="cov0" title="0">{
                player.Captures++
                player.Score += 50 // Points for capture
        }</span>

        <span class="cov0" title="0">g.EventBus.Publish(event.NewPlanetEvent(
                event.PlanetCaptured,
                g,
                uint64(planet.ID),
                ship.TeamID,
                oldTeamID,
        ))</span>
}

// beamArmiesUp handles beaming armies from a planet to a ship.
func (g *Game) beamArmiesUp(ship *entity.Ship, planet *entity.Planet, amount int) (int, error) <span class="cov0" title="0">{
        if planet.TeamID != ship.TeamID </span><span class="cov0" title="0">{
                return 0, errors.New("cannot beam up armies from enemy planet")
        }</span>

        <span class="cov0" title="0">if ship.Armies &gt;= ship.Stats.MaxArmies </span><span class="cov0" title="0">{
                return 0, errors.New("ship is at maximum army capacity")
        }</span>

        <span class="cov0" title="0">spaceAvailable := ship.Stats.MaxArmies - ship.Armies
        if amount &gt; spaceAvailable </span><span class="cov0" title="0">{
                amount = spaceAvailable
        }</span>

        <span class="cov0" title="0">transferred := planet.BeamUpArmies(ship.TeamID, amount)
        ship.Armies += transferred

        return transferred, nil</span>
}

// FireWeapon fires a weapon from a ship
func (g *Game) FireWeapon(shipID entity.ID, weaponIndex int) error <span class="cov8" title="1">{
        g.EntityLock.Lock()
        defer g.EntityLock.Unlock()

        ship, err := g.findActiveShip(shipID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">projectile := ship.FireWeapon(weaponIndex)
        if projectile == nil </span><span class="cov0" title="0">{
                return nil // Weapon on cooldown or out of ammo
        }</span>

        <span class="cov0" title="0">g.registerAndPublishProjectile(projectile, ship.ID)
        return nil</span>
}

// findActiveShip finds a ship by ID and checks if it's active.
func (g *Game) findActiveShip(shipID entity.ID) (*entity.Ship, error) <span class="cov8" title="1">{
        ship, ok := g.Ships[shipID]
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.New("ship not found")
        }</span>
        <span class="cov8" title="1">if !ship.Active </span><span class="cov8" title="1">{
                return nil, errors.New("ship is not active")
        }</span>
        <span class="cov0" title="0">return ship, nil</span>
}

// registerAndPublishProjectile adds the projectile to the game and publishes an event.
func (g *Game) registerAndPublishProjectile(projectile *entity.Projectile, ownerID entity.ID) <span class="cov0" title="0">{
        projectile.OwnerID = ownerID
        g.Projectiles[projectile.ID] = projectile

        g.EventBus.Publish(&amp;event.BaseEvent{
                EventType: event.ProjectileFired,
                Source:    projectile,
        })
}</span>

// findSpawnPoint finds a suitable spawn point for a ship
func (g *Game) findSpawnPoint(teamID int) physics.Vector2D <span class="cov8" title="1">{
        if pos, ok := g.findSpawnPointNearHomeworld(teamID); ok </span><span class="cov8" title="1">{
                return pos
        }</span>
        <span class="cov8" title="1">return g.findRandomSpawnPoint()</span>
}

// findSpawnPointNearHomeworld tries to find a spawn point near a team's planet.
func (g *Game) findSpawnPointNearHomeworld(teamID int) (physics.Vector2D, bool) <span class="cov8" title="1">{
        for _, planet := range g.Planets </span><span class="cov8" title="1">{
                if planet.TeamID == teamID </span><span class="cov8" title="1">{
                        angle := rand.Float64() * 2 * math.Pi
                        distance := planet.Collider.Radius + 100 + rand.Float64()*100
                        return physics.Vector2D{
                                X: planet.Position.X + math.Cos(angle)*distance,
                                Y: planet.Position.Y + math.Sin(angle)*distance,
                        }, true
                }</span>
        }
        <span class="cov8" title="1">return physics.Vector2D{}, false</span>
}

// findRandomSpawnPoint returns a random position in the world.
func (g *Game) findRandomSpawnPoint() physics.Vector2D <span class="cov8" title="1">{
        worldSize := g.Config.WorldSize
        halfWorld := worldSize / 2

        return physics.Vector2D{
                X: rand.Float64()*worldSize - halfWorld,
                Y: rand.Float64()*worldSize - halfWorld,
        }
}</span>

// GetGameState returns a snapshot of the current game state
func (g *Game) GetGameState() *GameState <span class="cov8" title="1">{
        g.EntityLock.RLock()
        defer g.EntityLock.RUnlock()

        return g.createGameStateSnapshot()
}</span>

// createGameStateSnapshot builds and returns the complete game state.
func (g *Game) createGameStateSnapshot() *GameState <span class="cov8" title="1">{
        return &amp;GameState{
                Tick:        g.CurrentTick,
                Ships:       g.getShipStates(),
                Planets:     g.getPlanetStates(),
                Projectiles: g.getProjectileStates(),
                Teams:       g.getTeamStates(),
        }
}</span>

// getShipStates creates a snapshot of the current ship states.
func (g *Game) getShipStates() map[entity.ID]ShipState <span class="cov8" title="1">{
        states := make(map[entity.ID]ShipState)
        for id, ship := range g.Ships </span><span class="cov8" title="1">{
                if ship.Active </span><span class="cov8" title="1">{
                        states[id] = ShipState{
                                ID:       id,
                                Position: ship.Position,
                                Rotation: ship.Rotation,
                                Velocity: ship.Velocity,
                                Hull:     ship.Hull,
                                Shields:  ship.Shields,
                                Fuel:     ship.Fuel,
                                Armies:   ship.Armies,
                                TeamID:   ship.TeamID,
                                Class:    ship.Class,
                        }
                }</span>
        }
        <span class="cov8" title="1">return states</span>
}

// getPlanetStates creates a snapshot of the current planet states.
func (g *Game) getPlanetStates() map[entity.ID]PlanetState <span class="cov8" title="1">{
        states := make(map[entity.ID]PlanetState)
        for id, planet := range g.Planets </span><span class="cov8" title="1">{
                states[id] = PlanetState{
                        ID:       id,
                        Name:     planet.Name,
                        Position: planet.Position,
                        TeamID:   planet.TeamID,
                        Armies:   planet.Armies,
                }
        }</span>
        <span class="cov8" title="1">return states</span>
}

// getProjectileStates creates a snapshot of the current projectile states.
func (g *Game) getProjectileStates() map[entity.ID]ProjectileState <span class="cov8" title="1">{
        states := make(map[entity.ID]ProjectileState)
        for id, proj := range g.Projectiles </span><span class="cov0" title="0">{
                if proj.Active </span><span class="cov0" title="0">{
                        states[id] = ProjectileState{
                                ID:       id,
                                Position: proj.Position,
                                Velocity: proj.Velocity,
                                Type:     proj.Type,
                                TeamID:   proj.TeamID,
                        }
                }</span>
        }
        <span class="cov8" title="1">return states</span>
}

// getTeamStates creates a snapshot of the current team states.
func (g *Game) getTeamStates() map[int]TeamState <span class="cov8" title="1">{
        states := make(map[int]TeamState)
        for id, team := range g.Teams </span><span class="cov8" title="1">{
                states[id] = TeamState{
                        ID:          id,
                        Name:        team.Name,
                        Color:       team.Color,
                        Score:       team.Score,
                        ShipCount:   team.ShipCount,
                        PlanetCount: team.PlanetCount,
                }
        }</span>
        <span class="cov8" title="1">return states</span>
}

// GameState represents a snapshot of the game state
type GameState struct {
        Tick        uint64
        Ships       map[entity.ID]ShipState
        Planets     map[entity.ID]PlanetState
        Projectiles map[entity.ID]ProjectileState
        Teams       map[int]TeamState
}

// ShipState represents a snapshot of a ship's state
type ShipState struct {
        ID       entity.ID
        Position physics.Vector2D
        Rotation float64
        Velocity physics.Vector2D
        Hull     int
        Shields  int
        Fuel     int
        Armies   int
        TeamID   int
        Class    entity.ShipClass
}

// PlanetState represents a snapshot of a planet's state
type PlanetState struct {
        ID       entity.ID
        Name     string
        Position physics.Vector2D
        TeamID   int
        Armies   int
}

// ProjectileState represents a snapshot of a projectile's state
type ProjectileState struct {
        ID       entity.ID
        Position physics.Vector2D
        Velocity physics.Vector2D
        Type     string
        TeamID   int
}

// TeamState represents a snapshot of a team's state
type TeamState struct {
        ID          int
        Name        string
        Color       string
        Score       int
        ShipCount   int
        PlanetCount int
}

// registerEventHandlers registers handlers for game events
func (g *Game) registerEventHandlers() <span class="cov8" title="1">{
        g.EventBus.Subscribe(event.ShipDestroyed, g.handleShipDestroyedEvent)
}</span>

// handleShipDestroyedEvent handles the logic when a ship is destroyed.
func (g *Game) handleShipDestroyedEvent(e event.Event) <span class="cov8" title="1">{
        if _, ok := e.(*event.ShipEvent); !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for _, team := range g.Teams </span><span class="cov8" title="1">{
                if team.ShipCount == 0 </span><span class="cov8" title="1">{
                        g.endGameWithWinner()
                        return
                }</span>
        }
}

// endGameWithWinner determines the winner and ends the game.
func (g *Game) endGameWithWinner() <span class="cov8" title="1">{
        g.Status = GameStatusEnded
        g.EndTime = time.Now()

        var winnerID = -1
        maxPlanets := 0

        for id, t := range g.Teams </span><span class="cov8" title="1">{
                if t.PlanetCount &gt; maxPlanets </span><span class="cov8" title="1">{
                        maxPlanets = t.PlanetCount
                        winnerID = id
                }</span>
        }

        <span class="cov8" title="1">g.WinningTeam = winnerID

        var winnerSource interface{} = g
        if winner, ok := g.Teams[winnerID]; ok </span><span class="cov8" title="1">{
                winnerSource = winner
        }</span>

        <span class="cov8" title="1">g.EventBus.Publish(&amp;event.BaseEvent{
                EventType: event.GameEnded,
                Source:    winnerSource,
        })

        g.Running = false</span>
}

// Add helper method for ending the game
func (g *Game) endGame() <span class="cov8" title="1">{
        if g.Status == GameStatusEnded </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">g.Status = GameStatusEnded
        g.EndTime = time.Now()
        g.Running = false

        winnerID := g.determineWinner()
        g.WinningTeam = winnerID

        g.publishGameEndedEvent(winnerID)</span>
}

// determineWinner calculates the winning team based on game rules.
// It returns the winner's team ID, or -1 for a draw/no winner.
func (g *Game) determineWinner() int <span class="cov8" title="1">{
        // Use custom win condition if set
        if g.CustomWinCondition != nil </span><span class="cov8" title="1">{
                if winnerID, ok := g.CustomWinCondition.CheckWinner(g); ok </span><span class="cov8" title="1">{
                        return winnerID
                }</span>
        }

        // Default logic: score or conquest
        <span class="cov8" title="1">return g.calculateWinnerByDefaultRules()</span>
}

// calculateWinnerByDefaultRules determines the winner based on score or conquest.
func (g *Game) calculateWinnerByDefaultRules() int <span class="cov8" title="1">{
        var winnerID int = -1
        maxScore := -1 // Use -1 to handle zero scores correctly

        for id, team := range g.Teams </span><span class="cov8" title="1">{
                currentScore := 0
                if g.Config.GameRules.WinCondition == "conquest" </span><span class="cov0" title="0">{
                        currentScore = team.PlanetCount
                }</span> else<span class="cov8" title="1"> {
                        currentScore = team.Score
                }</span>

                <span class="cov8" title="1">if currentScore &gt; maxScore </span><span class="cov8" title="1">{
                        maxScore = currentScore
                        winnerID = id
                }</span> else<span class="cov8" title="1"> if currentScore == maxScore </span><span class="cov8" title="1">{
                        winnerID = -1 // Tie
                }</span>
        }
        <span class="cov8" title="1">return winnerID</span>
}

// publishGameEndedEvent sends the game ended event.
func (g *Game) publishGameEndedEvent(winnerID int) <span class="cov8" title="1">{
        var source interface{} = g
        if winnerID &gt;= 0 </span><span class="cov8" title="1">{
                if winner, ok := g.Teams[winnerID]; ok </span><span class="cov8" title="1">{
                        source = winner
                }</span>
        }
        <span class="cov8" title="1">g.EventBus.Publish(&amp;event.BaseEvent{
                EventType: event.GameEnded,
                Source:    source,
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// pkg/entity/entity.go
package entity

import (
        "github.com/opd-ai/go-netrek/pkg/physics"
)

// ID is a unique identifier for an entity
type ID uint64

// Entity is the base interface for all game objects
type Entity interface {
        GetID() ID
        GetPosition() physics.Vector2D
        GetCollider() physics.Circle
        Update(deltaTime float64)
        Render(r Renderer) // Interface for rendering
}

// BaseEntity contains common functionality for all entities
type BaseEntity struct {
        ID       ID
        Position physics.Vector2D
        Velocity physics.Vector2D
        Rotation float64
        Collider physics.Circle
        Active   bool
}

// GetID returns the entity's unique identifier
func (e *BaseEntity) GetID() ID <span class="cov8" title="1">{
        return e.ID
}</span>

// GetPosition returns the entity's position
func (e *BaseEntity) GetPosition() physics.Vector2D <span class="cov8" title="1">{
        return e.Position
}</span>

// GetCollider returns the entity's collision shape
func (e *BaseEntity) GetCollider() physics.Circle <span class="cov8" title="1">{
        return physics.Circle{
                Center: e.Position,
                Radius: e.Collider.Radius,
        }
}</span>

// Update updates the entity's position based on velocity
func (e *BaseEntity) Update(deltaTime float64) <span class="cov8" title="1">{
        e.Position = e.Position.Add(e.Velocity.Scale(deltaTime))
        // Update collider position
        e.Collider.Center = e.Position
}</span>

// Implement the missing method in BaseEntity
func (e *BaseEntity) Render(r Renderer) {<span class="cov8" title="1">
        // Base implementation does nothing, derived types will implement
}</span>

// Then implement the Entity.Render() method in each entity type:
func (s *Ship) Render(r Renderer) <span class="cov0" title="0">{
        r.RenderShip(s)
}</span>

func (p *Planet) Render(r Renderer) <span class="cov0" title="0">{
        r.RenderPlanet(p)
}</span>

func (p *Projectile) Render(r Renderer) <span class="cov0" title="0">{
        r.RenderProjectile(p)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// pkg/entity/planet.go
package entity

import (
        "github.com/opd-ai/go-netrek/pkg/physics"
)

// PlanetType defines the type of planet
type PlanetType int

const (
        Agricultural PlanetType = iota
        Industrial
        Military
        Homeworld
)

// Planet represents a planet in the Netrek galaxy
type Planet struct {
        BaseEntity
        Name        string
        Type        PlanetType
        TeamID      int // -1 for neutral
        Armies      int
        Resources   int
        Production  int
        Temperature int  // Affects bombing effectiveness
        Atmosphere  bool // Affects bombing
        MaxArmies   int
}

// NewPlanet creates a new planet
func NewPlanet(id ID, name string, position physics.Vector2D, planetType PlanetType) *Planet <span class="cov8" title="1">{
        planet := &amp;Planet{
                BaseEntity: BaseEntity{
                        ID:       id,
                        Position: position,
                        Collider: physics.Circle{
                                Center: position,
                                Radius: 50, // Planet size
                        },
                        Active: true,
                },
                Name:        name,
                Type:        planetType,
                TeamID:      -1, // Start neutral
                Armies:      10, // Default armies
                Resources:   100,
                Production:  5,
                Temperature: 50,
                Atmosphere:  true,
                MaxArmies:   100,
        }

        // Adjust properties based on planet type
        switch planetType </span>{
        case Agricultural:<span class="cov8" title="1">
                planet.Production = 8
                planet.MaxArmies = 80</span>
        case Industrial:<span class="cov8" title="1">
                planet.Resources = 200
                planet.Production = 10</span>
        case Military:<span class="cov8" title="1">
                planet.Armies = 20
                planet.MaxArmies = 120</span>
        case Homeworld:<span class="cov8" title="1">
                planet.Armies = 30
                planet.MaxArmies = 200
                planet.Production = 12</span>
        }

        <span class="cov8" title="1">return planet</span>
}

// Update handles the planet's state update for a single game tick
func (p *Planet) Update(deltaTime float64) <span class="cov8" title="1">{
        // Planets don't move, but they produce armies
        if p.TeamID &gt;= 0 </span><span class="cov8" title="1">{ // If owned by a team
                productionRate := float64(p.Production) * deltaTime / 10.0 // Armies per second
                newArmies := int(productionRate)

                if newArmies &gt; 0 &amp;&amp; p.Armies &lt; p.MaxArmies </span><span class="cov8" title="1">{
                        p.Armies += newArmies
                        if p.Armies &gt; p.MaxArmies </span><span class="cov8" title="1">{
                                p.Armies = p.MaxArmies
                        }</span>
                }
        }
}

// Bomb reduces the number of armies on the planet
func (p *Planet) Bomb(damage int) int <span class="cov8" title="1">{
        // Can't bomb a planet with your own team ID
        if p.Armies &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Adjust damage based on planet properties
        <span class="cov8" title="1">if p.Atmosphere </span><span class="cov8" title="1">{
                damage = int(float64(damage) * 0.7) // Atmosphere reduces bombing effectiveness
        }</span>

        // Apply temperature factor
        <span class="cov8" title="1">tempFactor := 1.0 - (float64(p.Temperature)/100.0)*0.5
        damage = int(float64(damage) * tempFactor)

        // Ensure at least 1 damage if bombing
        if damage &lt;= 0 </span><span class="cov0" title="0">{
                damage = 1
        }</span>

        // Apply damage to armies
        <span class="cov8" title="1">if damage &gt; p.Armies </span><span class="cov8" title="1">{
                damage = p.Armies
        }</span>

        <span class="cov8" title="1">p.Armies -= damage

        // If all armies are destroyed and planet was owned, make it neutral
        if p.Armies == 0 &amp;&amp; p.TeamID &gt;= 0 </span><span class="cov8" title="1">{
                p.TeamID = -1
        }</span>

        <span class="cov8" title="1">return damage</span>
}

// BeamDownArmies transfers armies from a ship to the planet
func (p *Planet) BeamDownArmies(shipTeamID, amount int) (transferred int, captured bool) <span class="cov8" title="1">{
        // Can't beam to enemy planets without conquering
        if p.TeamID &gt;= 0 &amp;&amp; p.TeamID != shipTeamID </span><span class="cov8" title="1">{
                return 0, false
        }</span>

        // If planet is neutral or friendly
        <span class="cov8" title="1">if p.TeamID == -1 || p.TeamID == shipTeamID </span><span class="cov8" title="1">{
                // Limit transfer to available space
                spaceAvailable := p.MaxArmies - p.Armies
                if amount &gt; spaceAvailable </span><span class="cov8" title="1">{
                        amount = spaceAvailable
                }</span>

                <span class="cov8" title="1">p.Armies += amount

                // If planet was neutral and now has armies, it's captured
                if p.TeamID == -1 &amp;&amp; p.Armies &gt; 0 </span><span class="cov8" title="1">{
                        p.TeamID = shipTeamID
                        captured = true
                }</span>

                <span class="cov8" title="1">return amount, captured</span>
        }

        <span class="cov0" title="0">return 0, false</span>
}

// BeamUpArmies transfers armies from the planet to a ship
func (p *Planet) BeamUpArmies(shipTeamID, maxAmount int) int <span class="cov8" title="1">{
        // Can only beam up from friendly planets
        if p.TeamID != shipTeamID || p.Armies &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Determine how many armies to transfer
        <span class="cov8" title="1">amount := maxAmount
        if amount &gt; p.Armies </span><span class="cov8" title="1">{
                amount = p.Armies
        }</span>

        <span class="cov8" title="1">p.Armies -= amount
        return amount</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// pkg/entity/ship.go
package entity

import (
        "time"

        "github.com/opd-ai/go-netrek/pkg/physics"
)

// ShipClass defines the type of ship and its capabilities
type ShipClass int

const (
        Scout ShipClass = iota
        Destroyer
        Cruiser
        Battleship
        Assault
)

// ShipStats contains the base statistics for a ship class
type ShipStats struct {
        MaxHull      int
        MaxShields   int
        MaxFuel      int
        Acceleration float64
        TurnRate     float64
        MaxSpeed     float64
        WeaponSlots  int
        MaxArmies    int
}

// Ship represents a player's spaceship in the Netrek game
type Ship struct {
        BaseEntity
        Class          ShipClass
        Stats          ShipStats
        TeamID         int
        PlayerID       ID
        Hull           int
        Shields        int
        Fuel           int
        Weapons        []Weapon
        Armies         int
        Cloaked        bool
        LastFired      map[string]time.Time
        Thrusting      bool
        TurningCW      bool
        TurningCCW     bool
        RepairMode     bool
        Damaged        bool
        Warping        bool
        LastDamageTime time.Time
        LastRepairTime time.Time
}

// NewShip creates a new ship with the specified class and team
func NewShip(id ID, class ShipClass, teamID int, position physics.Vector2D) *Ship <span class="cov8" title="1">{
        stats := getShipStats(class)

        ship := &amp;Ship{
                BaseEntity: BaseEntity{
                        ID:       id,
                        Position: position,
                        Rotation: 0,
                        Collider: physics.Circle{
                                Center: position,
                                Radius: 20, // Adjust based on ship class
                        },
                        Active: true,
                },
                Class:     class,
                Stats:     stats,
                TeamID:    teamID,
                Hull:      stats.MaxHull,
                Shields:   stats.MaxShields,
                Fuel:      stats.MaxFuel,
                Weapons:   make([]Weapon, 0, stats.WeaponSlots),
                LastFired: make(map[string]time.Time),
        }

        // Add default weapons
        ship.Weapons = append(ship.Weapons, NewTorpedo(id))
        ship.Weapons = append(ship.Weapons, NewPhaser(id))

        return ship
}</span>

// Update handles the ship's state update for a single game tick
func (s *Ship) Update(deltaTime float64) <span class="cov8" title="1">{
        s.updateRotation(deltaTime)
        s.updateAcceleration(deltaTime)
        s.applyDrag(deltaTime)
        s.BaseEntity.Update(deltaTime)
        s.regenerateShields(deltaTime)
}</span>

// updateRotation processes ship rotation based on turn input
func (s *Ship) updateRotation(deltaTime float64) <span class="cov8" title="1">{
        if s.TurningCW </span><span class="cov8" title="1">{
                s.Rotation += s.Stats.TurnRate * deltaTime
        }</span>
        <span class="cov8" title="1">if s.TurningCCW </span><span class="cov8" title="1">{
                s.Rotation -= s.Stats.TurnRate * deltaTime
        }</span>
}

// updateAcceleration handles thrust input, acceleration calculation, speed limiting, and fuel consumption
func (s *Ship) updateAcceleration(deltaTime float64) <span class="cov8" title="1">{
        if s.Thrusting &amp;&amp; s.Fuel &gt; 0 </span><span class="cov8" title="1">{
                // Calculate acceleration vector based on ship heading
                accelVector := physics.FromAngle(s.Rotation, s.Stats.Acceleration)
                s.Velocity = s.Velocity.Add(accelVector.Scale(deltaTime))

                // Cap speed at max speed
                if s.Velocity.Length() &gt; s.Stats.MaxSpeed </span><span class="cov0" title="0">{
                        s.Velocity = s.Velocity.Normalize().Scale(s.Stats.MaxSpeed)
                }</span>

                // Consume fuel
                <span class="cov8" title="1">s.Fuel--</span>
        }
}

// applyDrag reduces ship velocity over time due to space friction
func (s *Ship) applyDrag(deltaTime float64) <span class="cov8" title="1">{
        drag := 0.1 // Drag coefficient
        s.Velocity = s.Velocity.Scale(1.0 - drag*deltaTime)
}</span>

// regenerateShields increases shield strength over time up to maximum capacity
func (s *Ship) regenerateShields(deltaTime float64) <span class="cov8" title="1">{
        if s.Shields &lt; s.Stats.MaxShields </span><span class="cov8" title="1">{
                s.Shields += int(deltaTime * 5) // Adjust shield regen rate
                if s.Shields &gt; s.Stats.MaxShields </span><span class="cov0" title="0">{
                        s.Shields = s.Stats.MaxShields
                }</span>
        }
}

// FireWeapon attempts to fire the specified weapon
func (s *Ship) FireWeapon(weaponIndex int) *Projectile <span class="cov8" title="1">{
        if weaponIndex &lt; 0 || weaponIndex &gt;= len(s.Weapons) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">weapon := s.Weapons[weaponIndex]
        now := time.Now()

        // Check cooldown
        lastFired, exists := s.LastFired[weapon.GetName()]
        if exists &amp;&amp; now.Sub(lastFired) &lt; weapon.GetCooldown() </span><span class="cov8" title="1">{
                return nil // Weapon still on cooldown
        }</span>

        // Check fuel/energy requirements
        <span class="cov8" title="1">if s.Fuel &lt; weapon.GetFuelCost() </span><span class="cov0" title="0">{
                return nil // Not enough fuel
        }</span>

        // Create projectile
        <span class="cov8" title="1">projectile := weapon.CreateProjectile(s.ID, s.Position, s.Rotation, s.TeamID)

        // Update cooldown and consume resources
        s.LastFired[weapon.GetName()] = now
        s.Fuel -= weapon.GetFuelCost()

        return projectile</span>
}

// TakeDamage applies damage to the ship, first to shields then to hull
func (s *Ship) TakeDamage(amount int) bool <span class="cov8" title="1">{
        // Apply to shields first
        if s.Shields &gt; 0 </span><span class="cov8" title="1">{
                if s.Shields &gt;= amount </span><span class="cov8" title="1">{
                        s.Shields -= amount
                        amount = 0
                }</span> else<span class="cov8" title="1"> {
                        amount -= s.Shields
                        s.Shields = 0
                }</span>
        }

        // Apply remaining damage to hull
        <span class="cov8" title="1">if amount &gt; 0 </span><span class="cov8" title="1">{
                s.Hull -= amount
        }</span>

        // Check if ship is destroyed
        <span class="cov8" title="1">return s.Hull &lt;= 0</span>
}

func (s *Ship) RepairTick(deltaTime float64) <span class="cov8" title="1">{
        if !s.RepairMode </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">repairRate := float64(s.Stats.MaxHull) * 0.1 * deltaTime // 10% per second

        // Repair hull
        if s.Hull &lt; s.Stats.MaxHull </span><span class="cov8" title="1">{
                s.Hull += int(repairRate)
                if s.Hull &gt; s.Stats.MaxHull </span><span class="cov8" title="1">{
                        s.Hull = s.Stats.MaxHull
                }</span>
        }

        // Consume fuel while repairing
        <span class="cov8" title="1">s.Fuel -= int(deltaTime * 5) // 5 fuel per second
        if s.Fuel &lt; 0 </span><span class="cov8" title="1">{
                s.Fuel = 0
                s.RepairMode = false
        }</span>
}

var shipTypeStats map[string]ShipStats

// SetShipTypeStats allows the config loader to inject custom ship stats
func SetShipTypeStats(stats map[string]ShipStats) <span class="cov8" title="1">{
        shipTypeStats = stats
}</span>

// getShipStats returns the base statistics for a ship class, using config if available
func getShipStats(class ShipClass) ShipStats <span class="cov8" title="1">{
        name := class.String()
        if shipTypeStats != nil </span><span class="cov8" title="1">{
                if s, ok := shipTypeStats[name]; ok </span><span class="cov8" title="1">{
                        return s
                }</span>
        }
        <span class="cov8" title="1">switch class </span>{
        case Scout:<span class="cov8" title="1">
                return ShipStats{
                        MaxHull:      100,
                        MaxShields:   100,
                        MaxFuel:      1000,
                        Acceleration: 200,
                        TurnRate:     3.0,
                        MaxSpeed:     300,
                        WeaponSlots:  2,
                        MaxArmies:    2,
                }</span>
        case Destroyer:<span class="cov8" title="1">
                return ShipStats{
                        MaxHull:      150,
                        MaxShields:   150,
                        MaxFuel:      1200,
                        Acceleration: 150,
                        TurnRate:     2.5,
                        MaxSpeed:     250,
                        WeaponSlots:  3,
                        MaxArmies:    5,
                }</span>
        // Other ship classes would be defined here
        default:<span class="cov8" title="1">
                return ShipStats{
                        MaxHull:      120,
                        MaxShields:   120,
                        MaxFuel:      1000,
                        Acceleration: 180,
                        TurnRate:     2.8,
                        MaxSpeed:     280,
                        WeaponSlots:  2,
                        MaxArmies:    3,
                }</span>
        }
}

// String returns the string name for a ShipClass
func (c ShipClass) String() string <span class="cov8" title="1">{
        switch c </span>{
        case Scout:<span class="cov8" title="1">
                return "Scout"</span>
        case Destroyer:<span class="cov8" title="1">
                return "Destroyer"</span>
        case Cruiser:<span class="cov8" title="1">
                return "Cruiser"</span>
        case Battleship:<span class="cov8" title="1">
                return "Battleship"</span>
        case Assault:<span class="cov8" title="1">
                return "Assault"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// ShipClassFromString converts a string to a ShipClass enum value.
func ShipClassFromString(s string) ShipClass <span class="cov8" title="1">{
        switch s </span>{
        case "Scout":<span class="cov8" title="1">
                return Scout</span>
        case "Destroyer":<span class="cov8" title="1">
                return Destroyer</span>
        case "Cruiser":<span class="cov8" title="1">
                return Cruiser</span>
        case "Battleship":<span class="cov8" title="1">
                return Battleship</span>
        case "Assault":<span class="cov8" title="1">
                return Assault</span>
        default:<span class="cov8" title="1">
                return Scout</span> // fallback to Scout if unknown
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// pkg/entity/weapon.go
package entity

import (
        "sync/atomic"
        "time"

        "github.com/opd-ai/go-netrek/pkg/physics"
)

// Weapon interface defines the methods all weapons must implement
type Weapon interface {
        GetName() string
        GetCooldown() time.Duration
        GetFuelCost() int
        CreateProjectile(ownerID ID, position physics.Vector2D, angle float64, teamID int) *Projectile
}

// BaseWeapon contains common functionality for all weapons
type BaseWeapon struct {
        Name     string
        Cooldown time.Duration
        FuelCost int
        Damage   int
        Speed    float64
        OwnerID  ID
}

// GetName returns the weapon's name
func (w *BaseWeapon) GetName() string <span class="cov8" title="1">{
        return w.Name
}</span>

// GetCooldown returns the weapon's cooldown time
func (w *BaseWeapon) GetCooldown() time.Duration <span class="cov8" title="1">{
        return w.Cooldown
}</span>

// GetFuelCost returns the fuel cost to fire the weapon
func (w *BaseWeapon) GetFuelCost() int <span class="cov8" title="1">{
        return w.FuelCost
}</span>

// Torpedo weapon implementation
type Torpedo struct {
        BaseWeapon
        Range float64
}

// NewTorpedo creates a new torpedo weapon
func NewTorpedo(ownerID ID) *Torpedo <span class="cov8" title="1">{
        return &amp;Torpedo{
                BaseWeapon: BaseWeapon{
                        Name:     "Torpedo",
                        Cooldown: 500 * time.Millisecond,
                        FuelCost: 10,
                        Damage:   40,
                        Speed:    500,
                        OwnerID:  ownerID,
                },
                Range: 2000,
        }
}</span>

// CreateProjectile creates a torpedo projectile
func (t *Torpedo) CreateProjectile(ownerID ID, position physics.Vector2D, angle float64, teamID int) *Projectile <span class="cov8" title="1">{
        return &amp;Projectile{
                BaseEntity: BaseEntity{
                        ID:       GenerateID(),
                        Position: position,
                        Velocity: physics.FromAngle(angle, t.Speed),
                        Rotation: angle,
                        Collider: physics.Circle{
                                Center: position,
                                Radius: 5,
                        },
                        Active: true,
                },
                Type:             "Torpedo",
                OwnerID:          ownerID,
                TeamID:           teamID,
                Damage:           t.Damage,
                Range:            t.Range,
                DistanceTraveled: 0,
        }
}</span>

// Phaser weapon implementation
type Phaser struct {
        BaseWeapon
        Range float64
}

// NewPhaser creates a new phaser weapon
func NewPhaser(ownerID ID) *Phaser <span class="cov8" title="1">{
        return &amp;Phaser{
                BaseWeapon: BaseWeapon{
                        Name:     "Phaser",
                        Cooldown: 200 * time.Millisecond,
                        FuelCost: 5,
                        Damage:   20,
                        Speed:    1000,
                        OwnerID:  ownerID,
                },
                Range: 800,
        }
}</span>

// CreateProjectile creates a phaser projectile
func (p *Phaser) CreateProjectile(ownerID ID, position physics.Vector2D, angle float64, teamID int) *Projectile <span class="cov8" title="1">{
        return &amp;Projectile{
                BaseEntity: BaseEntity{
                        ID:       GenerateID(),
                        Position: position,
                        Velocity: physics.FromAngle(angle, p.Speed),
                        Rotation: angle,
                        Collider: physics.Circle{
                                Center: position,
                                Radius: 3,
                        },
                        Active: true,
                },
                Type:             "Phaser",
                OwnerID:          ownerID,
                TeamID:           teamID,
                Damage:           p.Damage,
                Range:            p.Range,
                DistanceTraveled: 0,
        }
}</span>

// Projectile represents a weapon projectile in the game
type Projectile struct {
        BaseEntity
        Type             string
        OwnerID          ID
        TeamID           int
        Damage           int
        Range            float64
        DistanceTraveled float64
}

// Update updates the projectile's position and checks if it has exceeded its range
func (p *Projectile) Update(deltaTime float64) <span class="cov8" title="1">{
        oldPos := p.Position
        p.BaseEntity.Update(deltaTime)

        // Calculate distance traveled in this frame
        distThisFrame := oldPos.Distance(p.Position)
        p.DistanceTraveled += distThisFrame

        // Deactivate if exceeded range
        if p.DistanceTraveled &gt;= p.Range </span><span class="cov8" title="1">{
                p.Active = false
        }</span>
}

// GenerateID generates a unique ID for entities
// Thread-safe ID generation using atomic operations
var nextID uint64

func GenerateID() ID <span class="cov8" title="1">{
        return ID(atomic.AddUint64(&amp;nextID, 1))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// pkg/event/event.go
package event

import (
        "sync"
)

// Type represents the type of event
type Type string

// Common event types
const (
        ShipCreated      Type = "ship_created"
        ShipDestroyed    Type = "ship_destroyed"
        PlanetCaptured   Type = "planet_captured"
        ProjectileFired  Type = "projectile_fired"
        EntityCollision  Type = "entity_collision"
        PlayerJoined     Type = "player_joined"
        PlayerLeft       Type = "player_left"
        GameStarted      Type = "game_started"
        GameEnded        Type = "game_ended"
        TeamScoreChanged Type = "team_score_changed"
)

// Subscription represents a subscription token
type Subscription struct {
        ID     uint64
        Cancel func()
}

// Event is the base interface for all events
type Event interface {
        GetType() Type
        GetSource() interface{}
}

// BaseEvent provides common functionality for all events
type BaseEvent struct {
        EventType Type
        Source    interface{}
}

// GetType returns the event type
func (e *BaseEvent) GetType() Type <span class="cov8" title="1">{
        return e.EventType
}</span>

// GetSource returns the event source
func (e *BaseEvent) GetSource() interface{} <span class="cov8" title="1">{
        return e.Source
}</span>

// Handler is a function that handles events
type Handler func(Event)

// handlerWrapper wraps a handler with an ID for unsubscription
type handlerWrapper struct {
        id      uint64
        handler Handler
}

// Bus manages event subscriptions and dispatching
type Bus struct {
        handlers map[Type][]handlerWrapper
        nextID   uint64
        mu       sync.RWMutex
}

// NewEventBus creates a new event bus
func NewEventBus() *Bus <span class="cov8" title="1">{
        return &amp;Bus{
                handlers: make(map[Type][]handlerWrapper),
                nextID:   1,
        }
}</span>

// Subscribe registers a handler for a specific event type and returns a subscription token
func (b *Bus) Subscribe(eventType Type, handler Handler) *Subscription <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        id := b.nextID
        b.nextID++

        wrapper := handlerWrapper{
                id:      id,
                handler: handler,
        }

        b.handlers[eventType] = append(b.handlers[eventType], wrapper)

        sub := &amp;Subscription{
                ID: id,
                Cancel: func() </span><span class="cov8" title="1">{
                        b.unsubscribeByID(eventType, id)
                }</span>,
        }

        <span class="cov8" title="1">return sub</span>
}

// unsubscribeByID removes a handler by its ID
func (b *Bus) unsubscribeByID(eventType Type, id uint64) <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        handlers, ok := b.handlers[eventType]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        // Find and remove the handler with matching ID
        <span class="cov8" title="1">for i, wrapper := range handlers </span><span class="cov8" title="1">{
                if wrapper.id == id </span><span class="cov8" title="1">{
                        b.handlers[eventType] = append(handlers[:i], handlers[i+1:]...)
                        break</span>
                }
        }
}

// Unsubscribe removes a handler for a specific event type (deprecated - use Subscription.Cancel instead)
func (b *Bus) Unsubscribe(eventType Type, handler Handler) {<span class="cov0" title="0">
        // This method is kept for backward compatibility but cannot work reliably
        // Users should use the Subscription.Cancel() method returned from Subscribe
}</span>

// Publish sends an event to all subscribed handlers
func (b *Bus) Publish(event Event) <span class="cov8" title="1">{
        b.mu.RLock()
        handlers, ok := b.handlers[event.GetType()]
        b.mu.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        // Call each handler
        <span class="cov8" title="1">for _, wrapper := range handlers </span><span class="cov8" title="1">{
                wrapper.handler(event)
        }</span>
}

// Specific event implementations

// ShipEvent contains information about ship-related events
type ShipEvent struct {
        BaseEvent
        ShipID uint64
        TeamID int
}

// NewShipEvent creates a new ship event
func NewShipEvent(eventType Type, source interface{}, shipID uint64, teamID int) *ShipEvent <span class="cov8" title="1">{
        return &amp;ShipEvent{
                BaseEvent: BaseEvent{
                        EventType: eventType,
                        Source:    source,
                },
                ShipID: shipID,
                TeamID: teamID,
        }
}</span>

// PlanetEvent contains information about planet-related events
type PlanetEvent struct {
        BaseEvent
        PlanetID  uint64
        TeamID    int
        OldTeamID int
}

// NewPlanetEvent creates a new planet event
func NewPlanetEvent(eventType Type, source interface{}, planetID uint64, teamID, oldTeamID int) *PlanetEvent <span class="cov8" title="1">{
        return &amp;PlanetEvent{
                BaseEvent: BaseEvent{
                        EventType: eventType,
                        Source:    source,
                },
                PlanetID:  planetID,
                TeamID:    teamID,
                OldTeamID: oldTeamID,
        }
}</span>

// CollisionEvent contains information about entity collisions
type CollisionEvent struct {
        BaseEvent
        EntityA uint64
        EntityB uint64
}

// NewCollisionEvent creates a new collision event
func NewCollisionEvent(source interface{}, entityA, entityB uint64) *CollisionEvent <span class="cov8" title="1">{
        return &amp;CollisionEvent{
                BaseEvent: BaseEvent{
                        EventType: EntityCollision,
                        Source:    source,
                },
                EntityA: entityA,
                EntityB: entityB,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// pkg/network/client.go
package network

import (
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "sync"
        "time"

        "github.com/opd-ai/go-netrek/pkg/engine"
        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/event"
)

// GameClient handles network communication with the server
type GameClient struct {
        conn                 net.Conn
        clientID             entity.ID
        playerID             entity.ID
        serverAddress        string
        connected            bool
        receivedStates       chan *engine.GameState
        eventBus             *event.Bus
        mu                   sync.Mutex
        latency              time.Duration
        lastPingTime         time.Time
        pingInterval         time.Duration
        reconnectDelay       time.Duration
        reconnectAttempts    int
        maxReconnectAttempts int
        DesiredShipClass     entity.ShipClass
}

// NewGameClient creates a new game client
func NewGameClient(eventBus *event.Bus) *GameClient <span class="cov8" title="1">{
        return &amp;GameClient{
                receivedStates:       make(chan *engine.GameState, 10),
                eventBus:             eventBus,
                pingInterval:         time.Second * 5,
                reconnectDelay:       time.Second * 3,
                maxReconnectAttempts: 5,
        }
}</span>

func (c *GameClient) RequestShipClass(class entity.ShipClass) error <span class="cov8" title="1">{
        c.DesiredShipClass = class

        // Send request to server
        request := struct {
                ShipClass entity.ShipClass `json:"shipClass"`
        }{
                ShipClass: class,
        }

        return c.sendMessage(RequestShipClass, request)
}</span>

// Connect connects to the game server
func (c *GameClient) Connect(address, playerName string, teamID int) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.prepareConnection(address)

        if err := c.establishTCPConnection(address); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.performHandshake(playerName, teamID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.startBackgroundProcesses()
        return nil</span>
}

// prepareConnection closes any existing connection and prepares for a new one.
func (c *GameClient) prepareConnection(address string) <span class="cov8" title="1">{
        if c.conn != nil </span><span class="cov0" title="0">{
                c.conn.Close()
                c.conn = nil
        }</span>
        <span class="cov8" title="1">c.connected = false
        c.serverAddress = address</span>
}

// establishTCPConnection creates a TCP connection to the server.
func (c *GameClient) establishTCPConnection(address string) error <span class="cov8" title="1">{
        var err error
        c.conn, err = net.Dial("tcp", address)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// performHandshake sends a connect request and processes the server's response.
func (c *GameClient) performHandshake(playerName string, teamID int) error <span class="cov0" title="0">{
        if err := c.sendConnectRequest(playerName, teamID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.processConnectResponse(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sendConnectRequest creates and sends the initial connection request to the server.
func (c *GameClient) sendConnectRequest(playerName string, teamID int) error <span class="cov0" title="0">{
        connectReq := struct {
                PlayerName string `json:"playerName"`
                TeamID     int    `json:"teamID"`
        }{
                PlayerName: playerName,
                TeamID:     teamID,
        }

        if err := c.sendMessage(ConnectRequest, connectReq); err != nil </span><span class="cov0" title="0">{
                c.cleanupConnection()
                return fmt.Errorf("failed to send connect request: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processConnectResponse reads and validates the server's connection response.
func (c *GameClient) processConnectResponse() error <span class="cov0" title="0">{
        msgType, data, err := c.readMessage()
        if err != nil </span><span class="cov0" title="0">{
                c.cleanupConnection()
                return fmt.Errorf("failed to read connect response: %w", err)
        }</span>

        <span class="cov0" title="0">if msgType != ConnectResponse </span><span class="cov0" title="0">{
                c.cleanupConnection()
                return fmt.Errorf("unexpected response type: %d", msgType)
        }</span>

        <span class="cov0" title="0">if err := c.parseAndValidateResponse(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// parseAndValidateResponse parses the connection response and updates client state.
func (c *GameClient) parseAndValidateResponse(data []byte) error <span class="cov0" title="0">{
        var connectResp struct {
                Success  bool      `json:"success"`
                Error    string    `json:"error"`
                PlayerID entity.ID `json:"playerID"`
                ClientID entity.ID `json:"clientID"`
        }

        if err := json.Unmarshal(data, &amp;connectResp); err != nil </span><span class="cov0" title="0">{
                c.cleanupConnection()
                return fmt.Errorf("failed to parse connect response: %w", err)
        }</span>

        <span class="cov0" title="0">if !connectResp.Success </span><span class="cov0" title="0">{
                c.cleanupConnection()
                return fmt.Errorf("server rejected connection: %s", connectResp.Error)
        }</span>

        <span class="cov0" title="0">c.playerID = connectResp.PlayerID
        c.clientID = connectResp.ClientID
        c.connected = true

        return nil</span>
}

// startBackgroundProcesses initiates the message and ping handling goroutines.
func (c *GameClient) startBackgroundProcesses() <span class="cov0" title="0">{
        go c.messageLoop()
        go c.pingLoop()
}</span>

// cleanupConnection safely closes the connection and resets state (must be called with lock held)
func (c *GameClient) cleanupConnection() <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                c.conn.Close()
                c.conn = nil
        }</span>
        <span class="cov0" title="0">c.connected = false</span>
}

// Disconnect disconnects from the game server
func (c *GameClient) Disconnect() error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if !c.connected </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Send disconnect notification
        <span class="cov0" title="0">c.sendMessage(DisconnectNotification, nil)

        // Clean up connection
        c.cleanupConnection()
        return nil</span>
}

// SendInput sends player input to the server
func (c *GameClient) SendInput(thrust, turnLeft, turnRight bool, fireWeapon int,
        beamDown, beamUp bool, beamAmount int, targetID entity.ID,
) error <span class="cov8" title="1">{
        if !c.connected </span><span class="cov8" title="1">{
                return errors.New("not connected")
        }</span>

        <span class="cov8" title="1">input := struct {
                Thrust     bool      `json:"thrust"`
                TurnLeft   bool      `json:"turnLeft"`
                TurnRight  bool      `json:"turnRight"`
                FireWeapon int       `json:"fireWeapon"`
                BeamDown   bool      `json:"beamDown"`
                BeamUp     bool      `json:"beamUp"`
                BeamAmount int       `json:"beamAmount"`
                TargetID   entity.ID `json:"targetID"`
        }{
                Thrust:     thrust,
                TurnLeft:   turnLeft,
                TurnRight:  turnRight,
                FireWeapon: fireWeapon,
                BeamDown:   beamDown,
                BeamUp:     beamUp,
                BeamAmount: beamAmount,
                TargetID:   targetID,
        }

        return c.sendMessage(PlayerInput, input)</span>
}

// SendChatMessage sends a chat message to the server
func (c *GameClient) SendChatMessage(message string) error <span class="cov8" title="1">{
        if !c.connected </span><span class="cov8" title="1">{
                return errors.New("not connected")
        }</span>

        <span class="cov0" title="0">chatMsg := struct {
                Message string `json:"message"`
        }{
                Message: message,
        }

        return c.sendMessage(ChatMessage, chatMsg)</span>
}

// GetLatency returns the current latency to the server
func (c *GameClient) GetLatency() time.Duration <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.latency
}</span>

// GetGameStateChannel returns the channel for receiving game states
func (c *GameClient) GetGameStateChannel() &lt;-chan *engine.GameState <span class="cov8" title="1">{
        return c.receivedStates
}</span>

// messageLoop handles incoming messages from the server
func (c *GameClient) messageLoop() <span class="cov0" title="0">{
        for c.connected </span><span class="cov0" title="0">{
                msgType, data, err := c.readMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if c.connected </span><span class="cov0" title="0">{
                                c.handleDisconnect(err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // Process message based on type
                <span class="cov0" title="0">switch msgType </span>{
                case GameStateUpdate:<span class="cov0" title="0">
                        c.handleGameStateUpdate(data)</span>

                case ChatMessage:<span class="cov0" title="0">
                        c.handleChatMessage(data)</span>

                case PingResponse:<span class="cov0" title="0">
                        c.handlePingResponse(data)</span>

                default:<span class="cov0" title="0"></span>
                        // Ignore unknown message types
                }
        }
}

// handleGameStateUpdate processes a game state update
func (c *GameClient) handleGameStateUpdate(data []byte) <span class="cov0" title="0">{
        var gameState engine.GameState
        if err := json.Unmarshal(data, &amp;gameState); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Send game state to channel, non-blocking
        <span class="cov0" title="0">select </span>{
        case c.receivedStates &lt;- &amp;gameState:<span class="cov0" title="0"></span>
                // State sent successfully
        default:<span class="cov0" title="0"></span>
                // Channel full, drop the state
        }
}

// handleChatMessage processes a chat message
func (c *GameClient) handleChatMessage(data []byte) <span class="cov0" title="0">{
        var chatMsg struct {
                SenderID   entity.ID `json:"senderID"`
                SenderName string    `json:"senderName"`
                TeamID     int       `json:"teamID"`
                Message    string    `json:"message"`
        }

        if err := json.Unmarshal(data, &amp;chatMsg); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create and publish chat event
        <span class="cov0" title="0">chatEvent := &amp;ChatEvent{
                BaseEvent: event.BaseEvent{
                        EventType: ChatMessageReceived,
                        Source:    c,
                },
                SenderID:   chatMsg.SenderID,
                SenderName: chatMsg.SenderName,
                TeamID:     chatMsg.TeamID,
                Message:    chatMsg.Message,
        }

        c.eventBus.Publish(chatEvent)</span>
}

// handlePingResponse processes a ping response
func (c *GameClient) handlePingResponse(data []byte) <span class="cov0" title="0">{
        var pingTime time.Time
        if err := json.Unmarshal(data, &amp;pingTime); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate latency
        <span class="cov0" title="0">c.mu.Lock()
        c.latency = time.Since(pingTime)
        c.mu.Unlock()</span>
}

// pingLoop periodically sends ping requests to the server
func (c *GameClient) pingLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(c.pingInterval)
        defer ticker.Stop()

        for c.connected </span><span class="cov0" title="0">{
                &lt;-ticker.C

                // Send ping request with current time
                c.mu.Lock()
                c.lastPingTime = time.Now()
                c.mu.Unlock()

                c.sendMessage(PingRequest, c.lastPingTime)
        }</span>
}

// handleDisconnect handles an unexpected disconnection
func (c *GameClient) handleDisconnect(err error) <span class="cov0" title="0">{
        c.mu.Lock()
        wasConnected := c.connected
        c.connected = false
        c.mu.Unlock()

        if !wasConnected </span><span class="cov0" title="0">{
                return
        }</span>

        // Publish disconnect event
        <span class="cov0" title="0">disconnectEvent := &amp;event.BaseEvent{
                EventType: ClientDisconnected,
                Source:    c,
        }
        c.eventBus.Publish(disconnectEvent)

        // Attempt to reconnect
        go c.attemptReconnect()</span>
}

// attemptReconnect tries to reconnect to the server
func (c *GameClient) attemptReconnect() <span class="cov0" title="0">{
        c.reconnectAttempts = 0

        for c.reconnectAttempts &lt; c.maxReconnectAttempts </span><span class="cov0" title="0">{
                c.reconnectAttempts++

                // Wait before attempting reconnect
                time.Sleep(c.reconnectDelay)

                // Try to reconnect
                err := c.Connect(c.serverAddress, "", 0) // Would need to store initial connection info
                if err == nil </span><span class="cov0" title="0">{
                        // Reconnected successfully
                        reconnectEvent := &amp;event.BaseEvent{
                                EventType: ClientReconnected,
                                Source:    c,
                        }
                        c.eventBus.Publish(reconnectEvent)
                        return
                }</span>
        }

        // Failed to reconnect after max attempts
        <span class="cov0" title="0">reconnectFailedEvent := &amp;event.BaseEvent{
                EventType: ClientReconnectFailed,
                Source:    c,
        }
        c.eventBus.Publish(reconnectFailedEvent)</span>
}

// readMessage reads a message from the server
func (c *GameClient) readMessage() (MessageType, []byte, error) <span class="cov0" title="0">{
        // Read message type
        var msgType MessageType
        if err := binary.Read(c.conn, binary.BigEndian, &amp;msgType); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        // Read message length
        <span class="cov0" title="0">var msgLen uint16
        if err := binary.Read(c.conn, binary.BigEndian, &amp;msgLen); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        // Read message data
        <span class="cov0" title="0">data := make([]byte, msgLen)
        if _, err := io.ReadFull(c.conn, data); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">return msgType, data, nil</span>
}

// sendMessage sends a message to the server
func (c *GameClient) sendMessage(msgType MessageType, msg interface{}) error <span class="cov8" title="1">{
        // Serialize message
        var data []byte
        var err error

        if msg != nil </span><span class="cov8" title="1">{
                data, err = json.Marshal(msg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                data = []byte{}
        }</span>

        // Check message size
        <span class="cov8" title="1">if len(data) &gt; 65535 </span><span class="cov0" title="0">{
                return errors.New("message too large")
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()

        if !c.connected </span><span class="cov0" title="0">{
                return errors.New("not connected")
        }</span>

        // Write message type
        <span class="cov8" title="1">if err := binary.Write(c.conn, binary.BigEndian, msgType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write message length
        <span class="cov8" title="1">msgLen := uint16(len(data))
        if err := binary.Write(c.conn, binary.BigEndian, msgLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write message data
        <span class="cov8" title="1">if _, err := c.conn.Write(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Client event types
const (
        ChatMessageReceived   event.Type = "chat_message_received"
        ClientDisconnected    event.Type = "client_disconnected"
        ClientReconnected     event.Type = "client_reconnected"
        ClientReconnectFailed event.Type = "client_reconnect_failed"
)

// ChatEvent contains information about a received chat message
type ChatEvent struct {
        event.BaseEvent
        SenderID   entity.ID
        SenderName string
        TeamID     int
        Message    string
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// pkg/network/server.go
package network

import (
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "sync"
        "time"

        "github.com/opd-ai/go-netrek/pkg/engine"
        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/physics"
)

// MessageType defines the type of network message
type MessageType byte

const (
        ConnectRequest MessageType = iota
        ConnectResponse
        DisconnectNotification
        GameStateUpdate
        PlayerInput
        ChatMessage
        PingRequest
        PingResponse
        RequestShipClass
)

// GameServer handles network communication and game state
type GameServer struct {
        listener      net.Listener
        game          *engine.Game
        clients       map[entity.ID]*Client
        clientsLock   sync.RWMutex
        running       bool
        updateRate    time.Duration
        maxClients    int
        ticksPerState int  // How many game ticks between full state updates
        partialState  bool // Whether to send partial updates between full updates
}

// Client represents a connected client
type Client struct {
        ID         entity.ID
        Conn       net.Conn
        PlayerID   entity.ID
        PlayerName string
        TeamID     int
        Connected  bool
        LastInput  time.Time
        Latency    time.Duration
}

// NewGameServer creates a new game server
func NewGameServer(game *engine.Game, maxClients int) *GameServer <span class="cov8" title="1">{
        nc := game.Config.NetworkConfig
        return &amp;GameServer{
                game:          game,
                clients:       make(map[entity.ID]*Client),
                running:       false,
                updateRate:    time.Second / time.Duration(nc.UpdateRate),
                maxClients:    maxClients,
                ticksPerState: nc.TicksPerState,
                partialState:  nc.UsePartialState,
        }
}</span>

// Start starts the game server
func (s *GameServer) Start(address string) error <span class="cov0" title="0">{
        var err error
        s.listener, err = net.Listen("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>

        <span class="cov0" title="0">s.running = true

        // Start game
        s.game.Start()

        // Start accepting connections
        go s.acceptConnections()

        // Start game update loop
        go s.gameLoop()

        log.Printf("Game server started on %s", address)
        return nil</span>
}

// Stop stops the game server
func (s *GameServer) Stop() <span class="cov0" title="0">{
        s.running = false

        // Close all client connections
        s.clientsLock.Lock()
        for _, client := range s.clients </span><span class="cov0" title="0">{
                client.Conn.Close()
        }</span>
        <span class="cov0" title="0">s.clientsLock.Unlock()

        // Close listener
        if s.listener != nil </span><span class="cov0" title="0">{
                s.listener.Close()
        }</span>

        // Stop game
        <span class="cov0" title="0">s.game.Stop()

        log.Println("Game server stopped")</span>
}

// acceptConnections accepts new client connections
func (s *GameServer) acceptConnections() <span class="cov0" title="0">{
        for s.running </span><span class="cov0" title="0">{
                conn, err := s.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        if s.running </span><span class="cov0" title="0">{
                                log.Printf("Error accepting connection: %v", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check if server is full
                <span class="cov0" title="0">s.clientsLock.RLock()
                clientCount := len(s.clients)
                s.clientsLock.RUnlock()

                if clientCount &gt;= s.maxClients </span><span class="cov0" title="0">{
                        log.Printf("Rejecting connection, server full")
                        conn.Close()
                        continue</span>
                }

                // Handle new connection
                <span class="cov0" title="0">go s.handleConnection(conn)</span>
        }
}

// handleConnection handles a new client connection
func (s *GameServer) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer conn.Close()

        connectReq, err := s.readAndValidateConnectRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">playerID, err := s.addPlayerToGame(conn, connectReq)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client := s.createAndRegisterClient(conn, playerID, connectReq)
        s.sendConnectionSuccessResponse(conn, playerID, client.ID)
        s.handleClientMessages(client)</span>
}

// readAndValidateConnectRequest reads and validates the initial connection request.
func (s *GameServer) readAndValidateConnectRequest(conn net.Conn) (*connectRequest, error) <span class="cov0" title="0">{
        msgType, data, err := s.readMessage(conn)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading connect request: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if msgType != ConnectRequest </span><span class="cov0" title="0">{
                log.Printf("Expected connect request, got %d", msgType)
                return nil, errors.New("invalid message type")
        }</span>

        <span class="cov0" title="0">var connectReq connectRequest
        if err := json.Unmarshal(data, &amp;connectReq); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing connect request: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;connectReq, nil</span>
}

// addPlayerToGame adds a new player to the game and handles errors.
func (s *GameServer) addPlayerToGame(conn net.Conn, connectReq *connectRequest) (entity.ID, error) <span class="cov0" title="0">{
        playerID, err := s.game.AddPlayer(connectReq.PlayerName, connectReq.TeamID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error adding player: %v", err)
                s.sendConnectionErrorResponse(conn, err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return playerID, nil</span>
}

// createAndRegisterClient creates a new client and registers it with the server.
func (s *GameServer) createAndRegisterClient(conn net.Conn, playerID entity.ID, connectReq *connectRequest) *Client <span class="cov0" title="0">{
        clientID := entity.GenerateID()
        client := &amp;Client{
                ID:         clientID,
                Conn:       conn,
                PlayerID:   playerID,
                PlayerName: connectReq.PlayerName,
                TeamID:     connectReq.TeamID,
                Connected:  true,
                LastInput:  time.Now(),
        }

        s.clientsLock.Lock()
        s.clients[clientID] = client
        s.clientsLock.Unlock()

        return client
}</span>

// sendConnectionErrorResponse sends an error response for failed connections.
func (s *GameServer) sendConnectionErrorResponse(conn net.Conn, err error) <span class="cov0" title="0">{
        errorResp := struct {
                Success bool   `json:"success"`
                Error   string `json:"error"`
        }{
                Success: false,
                Error:   err.Error(),
        }
        s.sendMessage(conn, ConnectResponse, errorResp)
}</span>

// sendConnectionSuccessResponse sends a success response for established connections.
func (s *GameServer) sendConnectionSuccessResponse(conn net.Conn, playerID, clientID entity.ID) <span class="cov0" title="0">{
        successResp := struct {
                Success  bool      `json:"success"`
                PlayerID entity.ID `json:"playerID"`
                ClientID entity.ID `json:"clientID"`
        }{
                Success:  true,
                PlayerID: playerID,
                ClientID: clientID,
        }
        s.sendMessage(conn, ConnectResponse, successResp)
}</span>

// connectRequest represents the structure of connection request data.
type connectRequest struct {
        PlayerName string `json:"playerName"`
        TeamID     int    `json:"teamID"`
}

// handleClientMessages processes messages from a connected client
func (s *GameServer) handleClientMessages(client *Client) <span class="cov0" title="0">{
        for client.Connected &amp;&amp; s.running </span><span class="cov0" title="0">{
                msgType, data, err := s.readMessage(client.Conn)
                if err != nil </span><span class="cov0" title="0">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                log.Printf("Error reading message from client %d: %v", client.ID, err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Process message based on type
                <span class="cov0" title="0">switch msgType </span>{
                case PlayerInput:<span class="cov0" title="0">
                        s.handlePlayerInput(client, data)</span>

                case PingRequest:<span class="cov0" title="0">
                        // Respond to ping request with ping response
                        s.sendMessage(client.Conn, PingResponse, data)</span>

                case ChatMessage:<span class="cov0" title="0">
                        // Broadcast chat message to all clients
                        s.broadcastChatMessage(client, data)</span>

                case DisconnectNotification:<span class="cov0" title="0">
                        // Client is disconnecting gracefully
                        log.Printf("Client %d disconnecting", client.ID)
                        client.Connected = false</span>

                default:<span class="cov0" title="0">
                        log.Printf("Unknown message type %d from client %d", msgType, client.ID)</span>
                }
        }

        // Client disconnected, clean up
        <span class="cov0" title="0">s.removeClient(client)</span>
}

// PlayerInputData represents the structure of player input messages
type PlayerInputData struct {
        Thrust     bool      `json:"thrust"`
        TurnLeft   bool      `json:"turnLeft"`
        TurnRight  bool      `json:"turnRight"`
        FireWeapon int       `json:"fireWeapon"` // -1 if not firing, weapon index otherwise
        BeamDown   bool      `json:"beamDown"`
        BeamUp     bool      `json:"beamUp"`
        BeamAmount int       `json:"beamAmount"`
        TargetID   entity.ID `json:"targetID"` // Target planet ID for beaming
}

// handlePlayerInput processes player input messages
func (s *GameServer) handlePlayerInput(client *Client, data []byte) <span class="cov0" title="0">{
        input, err := s.parsePlayerInput(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing player input: %v", err)
                return
        }</span>

        <span class="cov0" title="0">client.LastInput = time.Now()

        ship := s.findPlayerShip(client)
        if ship == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.applyPlayerInput(ship, input)</span>
}

// parsePlayerInput deserializes the player input data from JSON bytes
func (s *GameServer) parsePlayerInput(data []byte) (*PlayerInputData, error) <span class="cov0" title="0">{
        var input PlayerInputData
        if err := json.Unmarshal(data, &amp;input); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;input, nil</span>
}

// findPlayerShip locates the ship entity for a given client's player
func (s *GameServer) findPlayerShip(client *Client) *entity.Ship <span class="cov0" title="0">{
        s.game.EntityLock.RLock()
        defer s.game.EntityLock.RUnlock()

        for _, player := range s.game.Teams[client.TeamID].Players </span><span class="cov0" title="0">{
                if player.ID == client.PlayerID </span><span class="cov0" title="0">{
                        if ship, ok := s.game.Ships[player.ShipID]; ok </span><span class="cov0" title="0">{
                                return ship
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// applyPlayerInput applies all validated input commands to the player's ship
func (s *GameServer) applyPlayerInput(ship *entity.Ship, input *PlayerInputData) <span class="cov0" title="0">{
        s.game.EntityLock.Lock()
        defer s.game.EntityLock.Unlock()

        s.applyMovementInput(ship, input)
        s.applyWeaponInput(ship, input)
        s.applyBeamingInput(ship, input)
}</span>

// applyMovementInput updates ship movement controls based on player input
func (s *GameServer) applyMovementInput(ship *entity.Ship, input *PlayerInputData) <span class="cov0" title="0">{
        ship.Thrusting = input.Thrust
        ship.TurningCW = input.TurnRight
        ship.TurningCCW = input.TurnLeft
}</span>

// applyWeaponInput handles weapon firing commands from player input
func (s *GameServer) applyWeaponInput(ship *entity.Ship, input *PlayerInputData) <span class="cov0" title="0">{
        if input.FireWeapon &gt;= 0 </span><span class="cov0" title="0">{
                s.game.FireWeapon(ship.ID, input.FireWeapon)
        }</span>
}

// applyBeamingInput processes army beaming commands from player input
func (s *GameServer) applyBeamingInput(ship *entity.Ship, input *PlayerInputData) <span class="cov0" title="0">{
        if (input.BeamDown || input.BeamUp) &amp;&amp; input.TargetID != 0 </span><span class="cov0" title="0">{
                direction := "down"
                if input.BeamUp </span><span class="cov0" title="0">{
                        direction = "up"
                }</span>
                <span class="cov0" title="0">s.game.BeamArmies(ship.ID, input.TargetID, direction, input.BeamAmount)</span>
        }
}

// broadcastChatMessage sends a chat message to all connected clients
func (s *GameServer) broadcastChatMessage(sender *Client, data []byte) <span class="cov0" title="0">{
        var chatMsg struct {
                Message string `json:"message"`
                // Can include info about who sent it already
        }

        if err := json.Unmarshal(data, &amp;chatMsg); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing chat message: %v", err)
                return
        }</span>

        // Create message with sender info
        <span class="cov0" title="0">broadcastMsg := struct {
                SenderID   entity.ID `json:"senderID"`
                SenderName string    `json:"senderName"`
                TeamID     int       `json:"teamID"`
                Message    string    `json:"message"`
        }{
                SenderID:   sender.PlayerID,
                SenderName: sender.PlayerName,
                TeamID:     sender.TeamID,
                Message:    chatMsg.Message,
        }

        // Broadcast to all clients
        s.clientsLock.RLock()
        for _, client := range s.clients </span><span class="cov0" title="0">{
                if client.Connected </span><span class="cov0" title="0">{
                        s.sendMessage(client.Conn, ChatMessage, broadcastMsg)
                }</span>
        }
        <span class="cov0" title="0">s.clientsLock.RUnlock()</span>
}

// removeClient removes a client from the server
func (s *GameServer) removeClient(client *Client) <span class="cov0" title="0">{
        s.clientsLock.Lock()
        delete(s.clients, client.ID)
        s.clientsLock.Unlock()

        // Remove player from game
        s.game.RemovePlayer(client.PlayerID)

        log.Printf("Client %d removed", client.ID)
}</span>

// gameLoop runs the main game loop
func (s *GameServer) gameLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(s.updateRate)
        defer ticker.Stop()

        for s.running </span><span class="cov0" title="0">{
                &lt;-ticker.C

                // Update game state
                s.game.Update()

                // Send updates to clients
                if s.game.CurrentTick%uint64(s.ticksPerState) == 0 </span><span class="cov0" title="0">{
                        // Full state update
                        s.sendFullStateUpdate()
                }</span> else<span class="cov0" title="0"> if s.partialState </span><span class="cov0" title="0">{
                        // Partial state update
                        s.sendPartialStateUpdate()
                }</span>
        }
}

// sendFullStateUpdate sends a complete game state to all clients
func (s *GameServer) sendFullStateUpdate() <span class="cov0" title="0">{
        gameState := s.game.GetGameState()

        s.clientsLock.RLock()
        for _, client := range s.clients </span><span class="cov0" title="0">{
                if client.Connected </span><span class="cov0" title="0">{
                        s.sendMessage(client.Conn, GameStateUpdate, gameState)
                }</span>
        }
        <span class="cov0" title="0">s.clientsLock.RUnlock()</span>
}

// sendPartialStateUpdate sends only changed game state to clients
func (s *GameServer) sendPartialStateUpdate() <span class="cov0" title="0">{
        currentState := s.game.GetGameState()

        s.clientsLock.RLock()
        defer s.clientsLock.RUnlock()

        for _, client := range s.clients </span><span class="cov0" title="0">{
                if !client.Connected </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">partialState := s.createPartialStateForClient(client, currentState)
                s.sendMessage(client.Conn, GameStateUpdate, partialState)</span>
        }
}

// createPartialStateForClient creates a partial game state containing only entities visible to the client.
func (s *GameServer) createPartialStateForClient(client *Client, currentState *engine.GameState) *engine.GameState <span class="cov0" title="0">{
        partialState := s.initializePartialState(currentState)
        playerShipPos := s.findPlayerShipPosition(client, currentState)

        s.addNearbyEntities(partialState, currentState, playerShipPos)
        s.addAllPlanets(partialState, currentState)

        return partialState
}</span>

// initializePartialState creates an empty partial state with basic information.
func (s *GameServer) initializePartialState(currentState *engine.GameState) *engine.GameState <span class="cov0" title="0">{
        return &amp;engine.GameState{
                Tick:        currentState.Tick,
                Ships:       make(map[entity.ID]engine.ShipState),
                Planets:     make(map[entity.ID]engine.PlanetState),
                Projectiles: make(map[entity.ID]engine.ProjectileState),
                Teams:       currentState.Teams, // Teams always included
        }
}</span>

// findPlayerShipPosition locates the position of the client's ship for visibility calculations.
func (s *GameServer) findPlayerShipPosition(client *Client, currentState *engine.GameState) physics.Vector2D <span class="cov0" title="0">{
        for _, player := range s.game.Teams[client.TeamID].Players </span><span class="cov0" title="0">{
                if player.ID == client.PlayerID </span><span class="cov0" title="0">{
                        if ship, ok := currentState.Ships[player.ShipID]; ok </span><span class="cov0" title="0">{
                                return ship.Position
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">return physics.Vector2D{}</span> // Return zero vector if ship not found
}

// addNearbyEntities adds ships and projectiles within the view radius to the partial state.
func (s *GameServer) addNearbyEntities(partialState *engine.GameState, currentState *engine.GameState, playerPos physics.Vector2D) <span class="cov0" title="0">{
        viewRadius := 3000.0 // Default view radius

        // Add nearby ships
        for id, ship := range currentState.Ships </span><span class="cov0" title="0">{
                if ship.Position.Distance(playerPos) &lt;= viewRadius </span><span class="cov0" title="0">{
                        partialState.Ships[id] = ship
                }</span>
        }

        // Add nearby projectiles
        <span class="cov0" title="0">for id, proj := range currentState.Projectiles </span><span class="cov0" title="0">{
                if proj.Position.Distance(playerPos) &lt;= viewRadius </span><span class="cov0" title="0">{
                        partialState.Projectiles[id] = proj
                }</span>
        }
}

// addAllPlanets includes all planets in the partial state as they are always visible.
func (s *GameServer) addAllPlanets(partialState *engine.GameState, currentState *engine.GameState) <span class="cov0" title="0">{
        partialState.Planets = currentState.Planets
}</span>

// readMessage reads a message from a connection
func (s *GameServer) readMessage(conn net.Conn) (MessageType, []byte, error) <span class="cov0" title="0">{
        // Read message type
        var msgType MessageType
        if err := binary.Read(conn, binary.BigEndian, &amp;msgType); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        // Read message length
        <span class="cov0" title="0">var msgLen uint16
        if err := binary.Read(conn, binary.BigEndian, &amp;msgLen); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        // Read message data
        <span class="cov0" title="0">data := make([]byte, msgLen)
        if _, err := io.ReadFull(conn, data); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">return msgType, data, nil</span>
}

// sendMessage sends a message to a connection
func (s *GameServer) sendMessage(conn net.Conn, msgType MessageType, msg interface{}) error <span class="cov0" title="0">{
        // Serialize message
        data, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check message size
        <span class="cov0" title="0">if len(data) &gt; 65535 </span><span class="cov0" title="0">{
                return errors.New("message too large")
        }</span>

        // Write message type
        <span class="cov0" title="0">if err := binary.Write(conn, binary.BigEndian, msgType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write message length
        <span class="cov0" title="0">msgLen := uint16(len(data))
        if err := binary.Write(conn, binary.BigEndian, msgLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write message data
        <span class="cov0" title="0">if _, err := conn.Write(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// pkg/physics/collision.go
package physics

// Circle represents a circular collision shape
type Circle struct {
        Center Vector2D
        Radius float64
}

// Collides checks if two circles are colliding
func (c Circle) Collides(other Circle) bool <span class="cov8" title="1">{
        return c.Center.Distance(other.Center) &lt; c.Radius+other.Radius
}</span>

// CollisionResult contains information about a collision
type CollisionResult struct {
        Collided     bool
        Normal       Vector2D
        Penetration  float64
        ContactPoint Vector2D
}

// CheckCollision performs detailed collision detection between two circles
func CheckCollision(a, b Circle) CollisionResult <span class="cov8" title="1">{
        // Vector from A to B
        normal := b.Center.Sub(a.Center)
        distance := normal.Length()

        // No collision
        if distance &gt; a.Radius+b.Radius </span><span class="cov8" title="1">{
                return CollisionResult{Collided: false}
        }</span>

        // Get penetration depth
        <span class="cov8" title="1">penetration := a.Radius + b.Radius - distance

        // Calculate collision normal and contact point
        normal = normal.Normalize()
        contactPoint := a.Center.Add(normal.Scale(a.Radius))

        return CollisionResult{
                Collided:     true,
                Normal:       normal,
                Penetration:  penetration,
                ContactPoint: contactPoint,
        }</span>
}

// QuadTree for spatial partitioning
type QuadTree struct {
        Boundary  Rect
        Capacity  int
        Points    []Vector2D
        Objects   []interface{}
        Divided   bool
        NorthWest *QuadTree
        NorthEast *QuadTree
        SouthWest *QuadTree
        SouthEast *QuadTree
}

// Rect represents a rectangular area
type Rect struct {
        Center Vector2D
        Width  float64
        Height float64
}

func (r Rect) Contains(point Vector2D) bool <span class="cov8" title="1">{
        return point.X &gt;= r.Center.X-r.Width/2 &amp;&amp;
                point.X &lt; r.Center.X+r.Width/2 &amp;&amp;
                point.Y &gt;= r.Center.Y-r.Height/2 &amp;&amp;
                point.Y &lt; r.Center.Y+r.Height/2
}</span>

// NewQuadTree creates a new quad tree with the given boundary and capacity
func NewQuadTree(boundary Rect, capacity int) *QuadTree <span class="cov8" title="1">{
        return &amp;QuadTree{
                Boundary: boundary,
                Capacity: capacity,
                Points:   make([]Vector2D, 0, capacity),
                Objects:  make([]interface{}, 0, capacity),
                Divided:  false,
        }
}</span>

// pkg/physics/collision.go
func (qt *QuadTree) Insert(point Vector2D, object interface{}) bool <span class="cov8" title="1">{
        if !qt.Boundary.Contains(point) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(qt.Points) &lt; qt.Capacity &amp;&amp; !qt.Divided </span><span class="cov8" title="1">{
                qt.Points = append(qt.Points, point)
                qt.Objects = append(qt.Objects, object)
                return true
        }</span>

        <span class="cov8" title="1">if !qt.Divided </span><span class="cov8" title="1">{
                qt.Subdivide()
        }</span>

        <span class="cov8" title="1">return qt.NorthWest.Insert(point, object) ||
                qt.NorthEast.Insert(point, object) ||
                qt.SouthWest.Insert(point, object) ||
                qt.SouthEast.Insert(point, object)</span>
}

// Subdivide splits the quadtree into four quadrants
func (qt *QuadTree) Subdivide() <span class="cov8" title="1">{
        x := qt.Boundary.Center.X
        y := qt.Boundary.Center.Y
        w := qt.Boundary.Width / 2
        h := qt.Boundary.Height / 2

        nw := Rect{Center: Vector2D{X: x - w/2, Y: y + h/2}, Width: w, Height: h}
        ne := Rect{Center: Vector2D{X: x + w/2, Y: y + h/2}, Width: w, Height: h}
        sw := Rect{Center: Vector2D{X: x - w/2, Y: y - h/2}, Width: w, Height: h}
        se := Rect{Center: Vector2D{X: x + w/2, Y: y - h/2}, Width: w, Height: h}

        qt.NorthWest = NewQuadTree(nw, qt.Capacity)
        qt.NorthEast = NewQuadTree(ne, qt.Capacity)
        qt.SouthWest = NewQuadTree(sw, qt.Capacity)
        qt.SouthEast = NewQuadTree(se, qt.Capacity)
        qt.Divided = true
}</span>

// Query returns all objects that could be colliding with the given shape
func (qt *QuadTree) Query(area Rect) []interface{} <span class="cov8" title="1">{
        found := make([]interface{}, 0)

        // If area doesn't intersect boundary, return empty
        if !qt.intersects(area) </span><span class="cov8" title="1">{
                return found
        }</span>

        // Check objects in this quad
        <span class="cov8" title="1">for i, point := range qt.Points </span><span class="cov8" title="1">{
                if area.Contains(point) </span><span class="cov8" title="1">{
                        found = append(found, qt.Objects[i])
                }</span>
        }

        // If not divided, we're done
        <span class="cov8" title="1">if !qt.Divided </span><span class="cov8" title="1">{
                return found
        }</span>

        // Check children
        <span class="cov8" title="1">found = append(found, qt.NorthWest.Query(area)...)
        found = append(found, qt.NorthEast.Query(area)...)
        found = append(found, qt.SouthWest.Query(area)...)
        found = append(found, qt.SouthEast.Query(area)...)

        return found</span>
}

func (qt *QuadTree) intersects(area Rect) bool <span class="cov8" title="1">{
        return !(area.Center.X-area.Width/2 &gt; qt.Boundary.Center.X+qt.Boundary.Width/2 ||
                area.Center.X+area.Width/2 &lt; qt.Boundary.Center.X-qt.Boundary.Width/2 ||
                area.Center.Y-area.Height/2 &gt; qt.Boundary.Center.Y+qt.Boundary.Height/2 ||
                area.Center.Y+area.Height/2 &lt; qt.Boundary.Center.Y-qt.Boundary.Height/2)
}</span>

// Clear removes all points and objects from the QuadTree, but keeps its structure for reuse
func (qt *QuadTree) Clear() <span class="cov0" title="0">{
        qt.Points = qt.Points[:0]
        qt.Objects = qt.Objects[:0]
        if qt.Divided </span><span class="cov0" title="0">{
                qt.NorthWest.Clear()
                qt.NorthEast.Clear()
                qt.SouthWest.Clear()
                qt.SouthEast.Clear()
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package physics

// MovementState tracks ship physics
type MovementState struct {
        Position Vector2D
        Velocity Vector2D
        Heading  float64 // radians
        Mass     float64
        Thrust   float64
        MaxSpeed float64
}

func UpdateMovement(state *MovementState, deltaTime, thrustInput, turnInput float64) <span class="cov8" title="1">{
        // Apply rotation
        state.Heading += turnInput * deltaTime

        // Calculate thrust vector
        thrustVector := FromAngle(state.Heading, thrustInput*state.Thrust)

        // Update velocity
        state.Velocity = state.Velocity.Add(thrustVector.Scale(deltaTime))

        // Limit speed
        if state.Velocity.Length() &gt; state.MaxSpeed </span><span class="cov8" title="1">{
                state.Velocity = state.Velocity.Normalize().Scale(state.MaxSpeed)
        }</span>

        // Update position
        <span class="cov8" title="1">state.Position = state.Position.Add(state.Velocity.Scale(deltaTime))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// pkg/physics/vector.go
package physics

import "math"

// Vector2D represents a 2D vector with x and y components
type Vector2D struct {
        X float64
        Y float64
}

// Add returns the sum of two vectors
func (v Vector2D) Add(other Vector2D) Vector2D <span class="cov8" title="1">{
        return Vector2D{
                X: v.X + other.X,
                Y: v.Y + other.Y,
        }
}</span>

// Sub returns the difference between two vectors
func (v Vector2D) Sub(other Vector2D) Vector2D <span class="cov8" title="1">{
        return Vector2D{
                X: v.X - other.X,
                Y: v.Y - other.Y,
        }
}</span>

// Scale multiplies the vector by a scalar value
func (v Vector2D) Scale(factor float64) Vector2D <span class="cov8" title="1">{
        return Vector2D{
                X: v.X * factor,
                Y: v.Y * factor,
        }
}</span>

// Length returns the magnitude of the vector
func (v Vector2D) Length() float64 <span class="cov8" title="1">{
        return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</span>

// Normalize returns a unit vector in the same direction
func (v Vector2D) Normalize() Vector2D <span class="cov8" title="1">{
        length := v.Length()
        if length == 0 </span><span class="cov8" title="1">{
                return Vector2D{}
        }</span>
        <span class="cov8" title="1">return Vector2D{
                X: v.X / length,
                Y: v.Y / length,
        }</span>
}

// Distance returns the distance between two vectors
func (v Vector2D) Distance(other Vector2D) float64 <span class="cov8" title="1">{
        return v.Sub(other).Length()
}</span>

// Angle returns the angle of the vector in radians
func (v Vector2D) Angle() float64 <span class="cov8" title="1">{
        return math.Atan2(v.Y, v.X)
}</span>

// FromAngle creates a vector from an angle and magnitude
func FromAngle(angle, magnitude float64) Vector2D <span class="cov8" title="1">{
        return Vector2D{
                X: magnitude * math.Cos(angle),
                Y: magnitude * math.Sin(angle),
        }
}</span>

// Dot returns the dot product of two vectors
func (v Vector2D) Dot(other Vector2D) float64 <span class="cov8" title="1">{
        return v.X*other.X + v.Y*other.Y
}</span>

// Rotate rotates the vector by angle (in radians)
func (v Vector2D) Rotate(angle float64) Vector2D <span class="cov8" title="1">{
        cos := math.Cos(angle)
        sin := math.Sin(angle)
        return Vector2D{
                X: v.X*cos - v.Y*sin,
                Y: v.X*sin + v.Y*cos,
        }
}</span>

// LengthSquared returns magnitude squared (optimization for comparisons)
func (v Vector2D) LengthSquared() float64 <span class="cov8" title="1">{
        return v.X*v.X + v.Y*v.Y
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// pkg/render/engo/assets.go
package engo

import (
        "image"
        "image/color"
        "image/draw"

        "github.com/EngoEngine/engo/common"

        "github.com/opd-ai/go-netrek/pkg/entity"
)

// AssetManager handles loading and managing game assets
type AssetManager struct {
        // Ship sprites by class
        shipSprites map[entity.ShipClass]common.Drawable

        // Planet sprites by type
        planetSprites map[entity.PlanetType]common.Drawable

        // Projectile sprites by type
        projectileSprites map[string]common.Drawable

        // UI textures
        backgroundTexture common.Drawable
}

// NewAssetManager creates a new asset manager
func NewAssetManager() *AssetManager <span class="cov8" title="1">{
        return &amp;AssetManager{
                shipSprites:       make(map[entity.ShipClass]common.Drawable),
                planetSprites:     make(map[entity.PlanetType]common.Drawable),
                projectileSprites: make(map[string]common.Drawable),
        }
}</span>

// LoadAssets loads all game assets
func (am *AssetManager) LoadAssets() error <span class="cov0" title="0">{
        // Load ship sprites
        if err := am.loadShipSprites(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load planet sprites
        <span class="cov0" title="0">if err := am.loadPlanetSprites(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load projectile sprites
        <span class="cov0" title="0">if err := am.loadProjectileSprites(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load UI assets
        <span class="cov0" title="0">if err := am.loadUIAssets(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// loadShipSprites creates sprites for different ship classes
func (am *AssetManager) loadShipSprites() error <span class="cov0" title="0">{
        // Since we don't have image files, we'll create simple geometric shapes

        // Scout: Small triangle
        am.shipSprites[entity.Scout] = am.createShipSprite(16, 16, [][]int{
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        })

        // Destroyer: Medium triangle with more angular design
        am.shipSprites[entity.Destroyer] = am.createShipSprite(20, 20, [][]int{
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        })

        // Copy for other ship classes with variations
        am.shipSprites[entity.Cruiser] = am.shipSprites[entity.Destroyer]
        am.shipSprites[entity.Battleship] = am.shipSprites[entity.Destroyer]
        am.shipSprites[entity.Assault] = am.shipSprites[entity.Destroyer]

        return nil
}</span>

// loadPlanetSprites creates sprites for different planet types
func (am *AssetManager) loadPlanetSprites() error <span class="cov0" title="0">{
        // Create a simple circle for planets
        planetPattern := [][]int{
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
        }

        am.planetSprites[entity.Homeworld] = am.createShipSprite(12, 12, planetPattern)
        am.planetSprites[entity.Industrial] = am.createShipSprite(12, 12, planetPattern)
        am.planetSprites[entity.Agricultural] = am.createShipSprite(12, 12, planetPattern)
        am.planetSprites[entity.Military] = am.createShipSprite(12, 12, planetPattern)

        return nil
}</span>

// loadProjectileSprites creates sprites for different projectile types
func (am *AssetManager) loadProjectileSprites() error <span class="cov0" title="0">{
        // Torpedo: Small dot
        torpedoPattern := [][]int{
                {0, 1, 1, 0},
                {1, 1, 1, 1},
                {1, 1, 1, 1},
                {0, 1, 1, 0},
        }

        // Phaser: Line
        phaserPattern := [][]int{
                {1, 1},
                {1, 1},
        }

        am.projectileSprites["torpedo"] = am.createShipSprite(4, 4, torpedoPattern)
        am.projectileSprites["phaser"] = am.createShipSprite(2, 2, phaserPattern)

        return nil
}</span>

// loadUIAssets loads UI-related assets
func (am *AssetManager) loadUIAssets() error <span class="cov0" title="0">{
        // Create a simple starfield background
        backgroundPattern := make([][]int, 64)
        for i := range backgroundPattern </span><span class="cov0" title="0">{
                backgroundPattern[i] = make([]int, 64)
                // Add some random stars
                if i%8 == 0 &amp;&amp; (i/8)%3 == 0 </span><span class="cov0" title="0">{
                        backgroundPattern[i][i%64] = 1
                }</span>
        }

        <span class="cov0" title="0">am.backgroundTexture = am.createShipSprite(64, 64, backgroundPattern)

        return nil</span>
}

// createShipSprite creates a sprite from a 2D pattern
func (am *AssetManager) createShipSprite(width, height int, pattern [][]int) common.Drawable <span class="cov0" title="0">{
        // Create an image
        img := image.NewRGBA(image.Rect(0, 0, width, height))

        // Fill with transparent
        draw.Draw(img, img.Bounds(), &amp;image.Uniform{color.RGBA{0, 0, 0, 0}}, image.Point{}, draw.Src)

        // Draw pattern
        for y, row := range pattern </span><span class="cov0" title="0">{
                if y &gt;= height </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">for x, pixel := range row </span><span class="cov0" title="0">{
                        if x &gt;= width </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if pixel == 1 </span><span class="cov0" title="0">{
                                img.Set(x, y, color.RGBA{255, 255, 255, 255})
                        }</span>
                }
        }

        // Convert RGBA to NRGBA for Engo
        <span class="cov0" title="0">bounds := img.Bounds()
        nrgbaImg := image.NewNRGBA(bounds)
        for y := bounds.Min.Y; y &lt; bounds.Max.Y; y++ </span><span class="cov0" title="0">{
                for x := bounds.Min.X; x &lt; bounds.Max.X; x++ </span><span class="cov0" title="0">{
                        nrgbaImg.Set(x, y, img.At(x, y))
                }</span>
        }

        // Convert to Engo texture
        <span class="cov0" title="0">texture := common.NewImageObject(nrgbaImg)
        return common.NewTextureSingle(texture)</span>
}

// GetShipSprite returns the sprite for a ship class
func (am *AssetManager) GetShipSprite(class entity.ShipClass) common.Drawable <span class="cov8" title="1">{
        if sprite, exists := am.shipSprites[class]; exists </span><span class="cov0" title="0">{
                return sprite
        }</span>
        <span class="cov8" title="1">return am.shipSprites[entity.Scout]</span> // Default fallback
}

// GetPlanetSprite returns the sprite for a planet type
func (am *AssetManager) GetPlanetSprite(planetType entity.PlanetType) common.Drawable <span class="cov8" title="1">{
        if sprite, exists := am.planetSprites[planetType]; exists </span><span class="cov0" title="0">{
                return sprite
        }</span>
        <span class="cov8" title="1">return am.planetSprites[entity.Homeworld]</span> // Default fallback
}

// GetProjectileSprite returns the sprite for a projectile type
func (am *AssetManager) GetProjectileSprite(projectileType string) common.Drawable <span class="cov8" title="1">{
        if sprite, exists := am.projectileSprites[projectileType]; exists </span><span class="cov0" title="0">{
                return sprite
        }</span>
        <span class="cov8" title="1">return am.projectileSprites["torpedo"]</span> // Default fallback
}

// GetBackgroundTexture returns the background texture
func (am *AssetManager) GetBackgroundTexture() common.Drawable <span class="cov8" title="1">{
        return am.backgroundTexture
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// pkg/render/engo/camera.go
package engo

import (
        "github.com/EngoEngine/ecs"
        "github.com/EngoEngine/engo"
        "github.com/EngoEngine/engo/common"

        "github.com/opd-ai/go-netrek/pkg/physics"
)

// CameraSystem manages the game camera, following the player's ship
type CameraSystem struct {
        // Target to follow
        target    physics.Vector2D
        targetSet bool

        // Camera properties
        zoom    float32
        minZoom float32
        maxZoom float32

        // Smooth following
        followSpeed float32
        smoothing   bool

        // Current camera state
        currentPos physics.Vector2D
}

// NewCameraSystem creates a new camera system
func NewCameraSystem() *CameraSystem <span class="cov8" title="1">{
        return &amp;CameraSystem{
                zoom:        1.0,
                minZoom:     0.1,
                maxZoom:     3.0,
                followSpeed: 2.0,
                smoothing:   true,
        }
}</span>

// Add satisfies the ecs.System interface
func (cs *CameraSystem) Add(basic *ecs.BasicEntity, render *common.RenderComponent, space *common.SpaceComponent) {<span class="cov8" title="1">
        // Not used for camera system
}</span>

// Remove satisfies the ecs.System interface
func (cs *CameraSystem) Remove(basic ecs.BasicEntity) {<span class="cov8" title="1">
        // Not used for camera system
}</span>

// Update updates the camera position and zoom
func (cs *CameraSystem) Update(dt float32) <span class="cov0" title="0">{
        // Handle zoom input
        cs.handleZoomInput()

        // Update camera position to follow target
        if cs.targetSet </span><span class="cov0" title="0">{
                cs.updateCameraPosition(dt)
        }</span>

        // Apply camera transformation
        <span class="cov0" title="0">cs.applyCameraTransform()</span>
}

// handleZoomInput processes zoom-related input
func (cs *CameraSystem) handleZoomInput() <span class="cov0" title="0">{
        // Mouse wheel zoom
        scrollY := engo.Input.Mouse.ScrollY
        if scrollY != 0 </span><span class="cov0" title="0">{
                zoomFactor := float32(1.0 + scrollY*0.1)
                cs.SetZoom(cs.zoom * zoomFactor)
        }</span>

        // Keyboard zoom
        <span class="cov0" title="0">if engo.Input.Button("zoomIn").Down() </span><span class="cov0" title="0">{
                cs.SetZoom(cs.zoom * 1.02)
        }</span>
        <span class="cov0" title="0">if engo.Input.Button("zoomOut").Down() </span><span class="cov0" title="0">{
                cs.SetZoom(cs.zoom * 0.98)
        }</span>

        // Reset zoom
        <span class="cov0" title="0">if engo.Input.Button("resetZoom").JustPressed() </span><span class="cov0" title="0">{
                cs.SetZoom(1.0)
        }</span>
}

// updateCameraPosition smoothly moves the camera toward the target
func (cs *CameraSystem) updateCameraPosition(dt float32) <span class="cov8" title="1">{
        if cs.smoothing </span><span class="cov8" title="1">{
                // Smooth interpolation toward target
                dx := cs.target.X - cs.currentPos.X
                dy := cs.target.Y - cs.currentPos.Y

                cs.currentPos.X += dx * float64(cs.followSpeed) * float64(dt)
                cs.currentPos.Y += dy * float64(cs.followSpeed) * float64(dt)
        }</span> else<span class="cov8" title="1"> {
                // Immediate positioning
                cs.currentPos = cs.target
        }</span>
}

// applyCameraTransform applies the current camera transformation
func (cs *CameraSystem) applyCameraTransform() <span class="cov0" title="0">{
        // Set the camera position and zoom
        // Convert world coordinates to screen coordinates
        // Note: CameraMessage API may differ, using a simplified approach
        engo.Mailbox.Dispatch(common.CameraMessage{
                Axis: common.ZAxis,
                // TODO: Fix camera message format for proper camera control
        })
}</span>

// SetTarget sets the target position for the camera to follow
func (cs *CameraSystem) SetTarget(target physics.Vector2D) <span class="cov8" title="1">{
        cs.target = target
        cs.targetSet = true

        // If this is the first target, position camera immediately
        if !cs.smoothing || (cs.currentPos.X == 0 &amp;&amp; cs.currentPos.Y == 0) </span><span class="cov8" title="1">{
                cs.currentPos = target
        }</span>
}

// ClearTarget clears the camera target
func (cs *CameraSystem) ClearTarget() <span class="cov8" title="1">{
        cs.targetSet = false
}</span>

// SetZoom sets the camera zoom level
func (cs *CameraSystem) SetZoom(zoom float32) <span class="cov8" title="1">{
        cs.zoom = cs.clampZoom(zoom)
}</span>

// GetZoom returns the current zoom level
func (cs *CameraSystem) GetZoom() float32 <span class="cov8" title="1">{
        return cs.zoom
}</span>

// clampZoom ensures zoom is within valid bounds
func (cs *CameraSystem) clampZoom(zoom float32) float32 <span class="cov8" title="1">{
        if zoom &lt; cs.minZoom </span><span class="cov8" title="1">{
                return cs.minZoom
        }</span>
        <span class="cov8" title="1">if zoom &gt; cs.maxZoom </span><span class="cov8" title="1">{
                return cs.maxZoom
        }</span>
        <span class="cov8" title="1">return zoom</span>
}

// SetFollowSpeed sets the camera follow speed
func (cs *CameraSystem) SetFollowSpeed(speed float32) <span class="cov8" title="1">{
        cs.followSpeed = speed
}</span>

// GetFollowSpeed returns the current follow speed
func (cs *CameraSystem) GetFollowSpeed() float32 <span class="cov8" title="1">{
        return cs.followSpeed
}</span>

// EnableSmoothing enables or disables camera smoothing
func (cs *CameraSystem) EnableSmoothing(enabled bool) <span class="cov8" title="1">{
        cs.smoothing = enabled
}</span>

// IsSmoothing returns whether camera smoothing is enabled
func (cs *CameraSystem) IsSmoothing() bool <span class="cov8" title="1">{
        return cs.smoothing
}</span>

// GetCurrentPosition returns the current camera position
func (cs *CameraSystem) GetCurrentPosition() physics.Vector2D <span class="cov8" title="1">{
        return cs.currentPos
}</span>

// WorldToScreen converts world coordinates to screen coordinates
func (cs *CameraSystem) WorldToScreen(worldPos physics.Vector2D) physics.Vector2D <span class="cov8" title="1">{
        // Apply camera transformation
        relativeX := worldPos.X - cs.currentPos.X
        relativeY := worldPos.Y - cs.currentPos.Y

        // Apply zoom
        screenX := relativeX*float64(cs.zoom) + float64(engo.GameWidth()/2)
        screenY := relativeY*float64(cs.zoom) + float64(engo.GameHeight()/2)

        return physics.Vector2D{X: screenX, Y: screenY}
}</span>

// ScreenToWorld converts screen coordinates to world coordinates
func (cs *CameraSystem) ScreenToWorld(screenPos physics.Vector2D) physics.Vector2D <span class="cov8" title="1">{
        // Remove screen centering
        relativeX := screenPos.X - float64(engo.GameWidth()/2)
        relativeY := screenPos.Y - float64(engo.GameHeight()/2)

        // Remove zoom
        relativeX /= float64(cs.zoom)
        relativeY /= float64(cs.zoom)

        // Add camera position
        worldX := relativeX + cs.currentPos.X
        worldY := relativeY + cs.currentPos.Y

        return physics.Vector2D{X: worldX, Y: worldY}
}</span>

// SetZoomLimits sets the minimum and maximum zoom levels
func (cs *CameraSystem) SetZoomLimits(min, max float32) <span class="cov8" title="1">{
        cs.minZoom = min
        cs.maxZoom = max
        cs.zoom = cs.clampZoom(cs.zoom)
}</span>

// GetZoomLimits returns the current zoom limits
func (cs *CameraSystem) GetZoomLimits() (float32, float32) <span class="cov8" title="1">{
        return cs.minZoom, cs.maxZoom
}</span>

// SetupCameraControls sets up camera control key bindings
func SetupCameraControls() <span class="cov0" title="0">{
        // Note: Using simplified key constants as some may not be available
        // engo.Input.RegisterButton("zoomIn", engo.KeyPlus)   // TODO: Fix key constants
        // engo.Input.RegisterButton("zoomOut", engo.KeyMinus) // TODO: Fix key constants
        engo.Input.RegisterButton("resetZoom", engo.KeyR) // R key to reset zoom
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// pkg/render/engo/hud.go
package engo

import (
        "fmt"
        "image/color"
        "time"

        "github.com/EngoEngine/ecs"
        "github.com/EngoEngine/engo"
        "github.com/EngoEngine/engo/common"

        "github.com/opd-ai/go-netrek/pkg/engine"
)

// HUDSystem manages the heads-up display
type HUDSystem struct {
        // HUD entities
        hudEntities []*ecs.BasicEntity

        // Status display
        connectionStatus string

        // Chat system
        chatMessages []ChatMessage
        maxChatLines int

        // Ship status
        currentShip *engine.ShipState

        // Minimap
        minimapEnabled bool
        minimapSize    float32

        // Team status
        teamStates map[int]engine.TeamState

        // Font for text rendering
        font *common.Font

        // Colors
        hudColor      color.Color
        friendlyColor color.Color
        enemyColor    color.Color
        neutralColor  color.Color
}

// ChatMessage represents a chat message in the HUD
type ChatMessage struct {
        Sender    string
        Message   string
        Timestamp time.Time
        Color     color.Color
}

// NewHUDSystem creates a new HUD system
func NewHUDSystem() *HUDSystem <span class="cov0" title="0">{
        return &amp;HUDSystem{
                connectionStatus: "Connected",
                maxChatLines:     10,
                minimapEnabled:   true,
                minimapSize:      200.0,
                teamStates:       make(map[int]engine.TeamState),
                hudColor:         color.RGBA{255, 255, 255, 255},
                friendlyColor:    color.RGBA{0, 255, 0, 255},
                enemyColor:       color.RGBA{255, 0, 0, 255},
                neutralColor:     color.RGBA{128, 128, 128, 255},
        }
}</span>

// Add satisfies the ecs.System interface
func (hud *HUDSystem) Add(basic *ecs.BasicEntity, render *common.RenderComponent, space *common.SpaceComponent) {<span class="cov0" title="0">
        // Not used for HUD system
}</span>

// Remove satisfies the ecs.System interface
func (hud *HUDSystem) Remove(basic ecs.BasicEntity) {<span class="cov0" title="0">
        // Not used for HUD system
}</span>

// Update updates the HUD display
func (hud *HUDSystem) Update(dt float32) <span class="cov0" title="0">{
        // Clear previous HUD entities
        hud.clearHUDEntities()

        // Render HUD components
        hud.renderShipStatus()
        hud.renderChatWindow()
        hud.renderTeamStatus()
        hud.renderConnectionStatus()

        if hud.minimapEnabled </span><span class="cov0" title="0">{
                hud.renderMinimap()
        }</span>
}

// clearHUDEntities removes previous HUD entities
func (hud *HUDSystem) clearHUDEntities() <span class="cov0" title="0">{
        // In a real implementation, you would properly remove entities from ECS
        hud.hudEntities = hud.hudEntities[:0]
}</span>

// renderShipStatus renders the player's ship status panel
func (hud *HUDSystem) renderShipStatus() <span class="cov0" title="0">{
        if hud.currentShip == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create status panel
        <span class="cov0" title="0">statusText := fmt.Sprintf(
                "Hull: %d/%d\nShields: %d\nFuel: %d\nArmies: %d",
                hud.currentShip.Hull,
                100, // Max hull - this should come from ship stats
                hud.currentShip.Shields,
                hud.currentShip.Fuel,
                hud.currentShip.Armies,
        )

        // Render status text at top-left corner
        hud.renderText(statusText, 10, 10, hud.hudColor)</span>
}

// renderChatWindow renders the chat message window
func (hud *HUDSystem) renderChatWindow() <span class="cov0" title="0">{
        chatStartY := float32(engo.GameHeight()) - 200

        // Render chat background
        hud.renderRect(10, chatStartY, 400, 150, color.RGBA{0, 0, 0, 128})

        // Render chat messages
        y := chatStartY + 10
        for i := len(hud.chatMessages) - 1; i &gt;= 0 &amp;&amp; i &gt;= len(hud.chatMessages)-hud.maxChatLines; i-- </span><span class="cov0" title="0">{
                msg := hud.chatMessages[i]
                chatLine := fmt.Sprintf("[%s]: %s", msg.Sender, msg.Message)
                hud.renderText(chatLine, 15, y, msg.Color)
                y += 15
        }</span>
}

// renderTeamStatus renders team scores and status
func (hud *HUDSystem) renderTeamStatus() <span class="cov0" title="0">{
        startY := float32(100)

        for teamID, teamState := range hud.teamStates </span><span class="cov0" title="0">{
                teamText := fmt.Sprintf(
                        "%s: Score %d, Ships %d, Planets %d",
                        teamState.Name,
                        teamState.Score,
                        teamState.ShipCount,
                        teamState.PlanetCount,
                )

                teamColor := hud.getTeamColor(teamID)
                hud.renderText(teamText, 10, startY, teamColor)
                startY += 20
        }</span>
}

// renderConnectionStatus renders the connection status
func (hud *HUDSystem) renderConnectionStatus() <span class="cov0" title="0">{
        statusColor := hud.friendlyColor
        if hud.connectionStatus != "Connected" </span><span class="cov0" title="0">{
                statusColor = hud.enemyColor
        }</span>

        <span class="cov0" title="0">hud.renderText(
                "Status: "+hud.connectionStatus,
                float32(engo.GameWidth())-150,
                10,
                statusColor,
        )</span>
}

// renderMinimap renders a minimap showing the game world
func (hud *HUDSystem) renderMinimap() <span class="cov0" title="0">{
        minimapX := float32(engo.GameWidth()) - hud.minimapSize - 10
        minimapY := float32(10)

        // Render minimap background
        hud.renderRect(minimapX, minimapY, hud.minimapSize, hud.minimapSize, color.RGBA{0, 0, 0, 128})

        // Render minimap border
        hud.renderRectOutline(minimapX, minimapY, hud.minimapSize, hud.minimapSize, hud.hudColor)

        // Note: In a real implementation, you would render planets and ships on the minimap
        // based on the current game state
}</span>

// renderText renders text at the specified position
func (hud *HUDSystem) renderText(text string, x, y float32, textColor color.Color) <span class="cov0" title="0">{
        // Create a text entity
        basic := ecs.NewBasic()

        renderComponent := common.RenderComponent{
                Drawable: common.Text{
                        Font: hud.font,
                        Text: text,
                },
                Color: textColor,
        }

        spaceComponent := common.SpaceComponent{
                Position: engo.Point{X: x, Y: y},
                Width:    float32(len(text) * 8), // Approximate width
                Height:   16,                     // Approximate height
        }

        // Add to HUD entities
        hud.hudEntities = append(hud.hudEntities, &amp;basic)

        // Note: In a real implementation, you would add these components to the render system
        // This is a simplified version for demonstration
        _ = renderComponent // Use the component
        _ = spaceComponent  // Use the component
}</span>

// renderRect renders a filled rectangle
func (hud *HUDSystem) renderRect(x, y, width, height float32, rectColor color.Color) <span class="cov0" title="0">{
        // Create a rectangle entity
        basic := ecs.NewBasic()

        renderComponent := common.RenderComponent{
                Drawable: common.Rectangle{
                        BorderWidth: 0,
                        BorderColor: color.Transparent,
                },
                Color: rectColor,
        }

        spaceComponent := common.SpaceComponent{
                Position: engo.Point{X: x, Y: y},
                Width:    width,
                Height:   height,
        }

        // Add to HUD entities
        hud.hudEntities = append(hud.hudEntities, &amp;basic)

        // Note: In a real implementation, you would add these components to the render system
        _ = renderComponent // Use the component
        _ = spaceComponent  // Use the component
}</span>

// renderRectOutline renders a rectangle outline
func (hud *HUDSystem) renderRectOutline(x, y, width, height float32, outlineColor color.Color) <span class="cov0" title="0">{
        // Create a rectangle outline entity
        basic := ecs.NewBasic()

        renderComponent := common.RenderComponent{
                Drawable: common.Rectangle{
                        BorderWidth: 2,
                        BorderColor: outlineColor,
                },
                Color: color.Transparent,
        }

        spaceComponent := common.SpaceComponent{
                Position: engo.Point{X: x, Y: y},
                Width:    width,
                Height:   height,
        }

        // Add to HUD entities
        hud.hudEntities = append(hud.hudEntities, &amp;basic)

        // Note: In a real implementation, you would add these components to the render system
        _ = renderComponent // Use the component
        _ = spaceComponent  // Use the component
}</span>

// AddChatMessage adds a new chat message to the display
func (hud *HUDSystem) AddChatMessage(sender, message string) <span class="cov0" title="0">{
        chatMsg := ChatMessage{
                Sender:    sender,
                Message:   message,
                Timestamp: time.Now(),
                Color:     hud.hudColor,
        }

        hud.chatMessages = append(hud.chatMessages, chatMsg)

        // Keep only the most recent messages
        if len(hud.chatMessages) &gt; hud.maxChatLines*2 </span><span class="cov0" title="0">{
                hud.chatMessages = hud.chatMessages[len(hud.chatMessages)-hud.maxChatLines:]
        }</span>
}

// SetConnectionStatus sets the connection status display
func (hud *HUDSystem) SetConnectionStatus(status string) <span class="cov0" title="0">{
        hud.connectionStatus = status
}</span>

// UpdateGameState updates the HUD with current game state
func (hud *HUDSystem) UpdateGameState(gameState *engine.GameState) <span class="cov0" title="0">{
        hud.teamStates = gameState.Teams

        // Find the player's ship (this would need to be implemented based on player tracking)
        // For now, we'll use the first ship as an example
        for _, shipState := range gameState.Ships </span><span class="cov0" title="0">{
                hud.currentShip = &amp;shipState
                break</span>
        }
}

// getTeamColor returns the color for a specific team
func (hud *HUDSystem) getTeamColor(teamID int) color.Color <span class="cov0" title="0">{
        teamColors := []color.Color{
                color.RGBA{255, 0, 0, 255},   // Red
                color.RGBA{0, 255, 0, 255},   // Green
                color.RGBA{0, 0, 255, 255},   // Blue
                color.RGBA{255, 255, 0, 255}, // Yellow
        }

        if teamID &gt;= 0 &amp;&amp; teamID &lt; len(teamColors) </span><span class="cov0" title="0">{
                return teamColors[teamID]
        }</span>

        <span class="cov0" title="0">return hud.neutralColor</span>
}

// SetMinimapEnabled enables or disables the minimap
func (hud *HUDSystem) SetMinimapEnabled(enabled bool) <span class="cov0" title="0">{
        hud.minimapEnabled = enabled
}</span>

// IsMinimapEnabled returns whether the minimap is enabled
func (hud *HUDSystem) IsMinimapEnabled() bool <span class="cov0" title="0">{
        return hud.minimapEnabled
}</span>

// SetMinimapSize sets the size of the minimap
func (hud *HUDSystem) SetMinimapSize(size float32) <span class="cov0" title="0">{
        hud.minimapSize = size
}</span>

// GetMinimapSize returns the current minimap size
func (hud *HUDSystem) GetMinimapSize() float32 <span class="cov0" title="0">{
        return hud.minimapSize
}</span>

// SetFont sets the font used for HUD text rendering
func (hud *HUDSystem) SetFont(font *common.Font) <span class="cov0" title="0">{
        hud.font = font
}</span>

// GetChatMessages returns the current chat messages
func (hud *HUDSystem) GetChatMessages() []ChatMessage <span class="cov0" title="0">{
        return hud.chatMessages
}</span>

// ClearChatMessages clears all chat messages
func (hud *HUDSystem) ClearChatMessages() <span class="cov0" title="0">{
        hud.chatMessages = hud.chatMessages[:0]
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// pkg/render/engo/input.go
package engo

import (
        "time"

        "github.com/EngoEngine/ecs"
        "github.com/EngoEngine/engo"
        "github.com/EngoEngine/engo/common"

        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/network"
)

// InputSystem handles keyboard and mouse input for the game
type InputSystem struct {
        client *network.GameClient

        // Input state
        thrustPressed    bool
        turnLeftPressed  bool
        turnRightPressed bool
        currentWeapon    int
        targetID         entity.ID

        // Input timing
        lastInputSent time.Time
        inputDelay    time.Duration

        // Chat state
        chatActive bool
        chatBuffer string
        chatCursor int
}

// NewInputSystem creates a new input system
func NewInputSystem(client *network.GameClient) *InputSystem <span class="cov0" title="0">{
        return &amp;InputSystem{
                client:        client,
                currentWeapon: -1,                    // No weapon selected by default
                inputDelay:    time.Millisecond * 50, // Send input every 50ms
        }
}</span>

// Add satisfies the ecs.System interface
func (is *InputSystem) Add(basic *ecs.BasicEntity, render *common.RenderComponent, space *common.SpaceComponent) {<span class="cov0" title="0">
        // Not used for input system
}</span>

// Remove satisfies the ecs.System interface
func (is *InputSystem) Remove(basic ecs.BasicEntity) {<span class="cov0" title="0">
        // Not used for input system
}</span>

// Update processes input and sends commands to the server
func (is *InputSystem) Update(dt float32) <span class="cov0" title="0">{
        // Handle chat input if chat is active
        if is.chatActive </span><span class="cov0" title="0">{
                is.handleChatInput()
                return
        }</span>

        // Handle game input
        <span class="cov0" title="0">is.handleGameInput()

        // Send input to server if enough time has passed
        if time.Since(is.lastInputSent) &gt;= is.inputDelay </span><span class="cov0" title="0">{
                is.sendInputToServer()
                is.lastInputSent = time.Now()
        }</span>
}

// handleGameInput processes game-related input
func (is *InputSystem) handleGameInput() <span class="cov0" title="0">{
        // Movement controls
        is.thrustPressed = engo.Input.Button("thrust").Down()
        is.turnLeftPressed = engo.Input.Button("turnLeft").Down()
        is.turnRightPressed = engo.Input.Button("turnRight").Down()

        // Weapon selection (number keys 1-9)
        for i := 1; i &lt;= 9; i++ </span><span class="cov0" title="0">{
                if engo.Input.Button(string(rune('0' + i))).JustPressed() </span><span class="cov0" title="0">{
                        is.currentWeapon = i - 1 // Convert to 0-based index
                }</span>
        }

        // Chat activation
        <span class="cov0" title="0">if engo.Input.Button("chat").JustPressed() </span><span class="cov0" title="0">{
                is.activateChat()
        }</span>

        // Targeting (for now, we'll use a placeholder implementation)
        <span class="cov0" title="0">if engo.Input.Button("target").JustPressed() </span><span class="cov0" title="0">{
                is.targetID = is.findNearestTarget()
        }</span>
}

// handleChatInput processes chat input when chat is active
func (is *InputSystem) handleChatInput() <span class="cov0" title="0">{
        // Handle text input for chat
        // Note: Engo doesn't have TextInput(), so we'll use a simplified approach
        // for now with just Enter and Backspace keys
        if engo.Input.Button("enter").JustPressed() </span><span class="cov0" title="0">{
                // Send chat message
                is.sendChatMessage()
                is.deactivateChat()
        }</span> else<span class="cov0" title="0"> if engo.Input.Button("backspace").JustPressed() </span><span class="cov0" title="0">{
                // Backspace
                if len(is.chatBuffer) &gt; 0 &amp;&amp; is.chatCursor &gt; 0 </span><span class="cov0" title="0">{
                        is.chatBuffer = is.chatBuffer[:is.chatCursor-1] + is.chatBuffer[is.chatCursor:]
                        is.chatCursor--
                }</span>
        }

        // Handle escape to cancel chat
        <span class="cov0" title="0">if engo.Input.Button("escape").JustPressed() </span><span class="cov0" title="0">{
                is.deactivateChat()
        }</span>
}

// sendInputToServer sends the current input state to the server
func (is *InputSystem) sendInputToServer() <span class="cov0" title="0">{
        fireWeapon := -1
        if engo.Input.Button("fire").JustPressed() &amp;&amp; is.currentWeapon &gt;= 0 </span><span class="cov0" title="0">{
                fireWeapon = is.currentWeapon
        }</span>

        <span class="cov0" title="0">beamDown := engo.Input.Button("beamDown").Down()
        beamUp := engo.Input.Button("beamUp").Down()
        beamAmount := 1 // Default beam amount

        // Adjust beam amount based on modifier keys
        if engo.Input.Button("modifier").Down() </span><span class="cov0" title="0">{
                beamAmount = 5
        }</span>

        // Send input to server
        <span class="cov0" title="0">err := is.client.SendInput(
                is.thrustPressed,
                is.turnLeftPressed,
                is.turnRightPressed,
                fireWeapon,
                beamDown,
                beamUp,
                beamAmount,
                is.targetID,
        )

        if err != nil </span><span class="cov0" title="0">{
                // Log error (use fmt.Printf since engo.Log doesn't exist)
                // fmt.Printf("Failed to send input: %v\n", err)
                _ = err // Suppress error for now
        }</span>
}

// activateChat activates chat input mode
func (is *InputSystem) activateChat() <span class="cov0" title="0">{
        is.chatActive = true
        is.chatBuffer = ""
        is.chatCursor = 0
}</span>

// deactivateChat deactivates chat input mode
func (is *InputSystem) deactivateChat() <span class="cov0" title="0">{
        is.chatActive = false
        is.chatBuffer = ""
        is.chatCursor = 0
}</span>

// sendChatMessage sends the current chat buffer as a message
func (is *InputSystem) sendChatMessage() <span class="cov0" title="0">{
        if len(is.chatBuffer) &gt; 0 </span><span class="cov0" title="0">{
                err := is.client.SendChatMessage(is.chatBuffer)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error (use fmt.Printf since engo.Log doesn't exist)
                        // fmt.Printf("Failed to send chat message: %v\n", err)
                        _ = err // Suppress error for now
                }</span>
        }
}

// findNearestTarget finds the nearest targetable entity
// This is a placeholder implementation
func (is *InputSystem) findNearestTarget() entity.ID <span class="cov0" title="0">{
        // In a real implementation, this would:
        // 1. Get the current game state
        // 2. Find the player's ship position
        // 3. Find the nearest enemy ship or planet
        // 4. Return its ID
        return 0 // Placeholder
}</span>

// IsChatActive returns whether chat input is currently active
func (is *InputSystem) IsChatActive() bool <span class="cov0" title="0">{
        return is.chatActive
}</span>

// GetChatBuffer returns the current chat input buffer
func (is *InputSystem) GetChatBuffer() string <span class="cov0" title="0">{
        return is.chatBuffer
}</span>

// GetChatCursor returns the current chat cursor position
func (is *InputSystem) GetChatCursor() int <span class="cov0" title="0">{
        return is.chatCursor
}</span>

// SetupInputBindings sets up the key bindings for the game
func SetupInputBindings() <span class="cov0" title="0">{
        // Movement keys
        engo.Input.RegisterButton("thrust", engo.KeyW, engo.KeyArrowUp)
        engo.Input.RegisterButton("turnLeft", engo.KeyA, engo.KeyArrowLeft)
        engo.Input.RegisterButton("turnRight", engo.KeyD, engo.KeyArrowRight)

        // Weapon and action keys
        engo.Input.RegisterButton("fire", engo.KeySpace)
        engo.Input.RegisterButton("beamDown", engo.KeyB)
        engo.Input.RegisterButton("beamUp", engo.KeyB) // With Shift modifier
        engo.Input.RegisterButton("target", engo.KeyT)

        // Number keys for weapon selection (simplified for now)
        // Note: Engo key constants may differ, using a simplified approach
        engo.Input.RegisterButton("weapon1", engo.KeyOne)
        engo.Input.RegisterButton("weapon2", engo.KeyTwo)
        engo.Input.RegisterButton("weapon3", engo.KeyThree)

        // UI keys
        engo.Input.RegisterButton("chat", engo.KeyEnter)
        engo.Input.RegisterButton("escape", engo.KeyEscape)
        engo.Input.RegisterButton("backspace", engo.KeyBackspace)
        engo.Input.RegisterButton("enter", engo.KeyEnter)
        engo.Input.RegisterButton("modifier", engo.KeyLeftShift)

        // Mouse bindings - separate registration for mouse
        // Note: Mouse buttons need to be handled differently in Engo
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// pkg/render/engo/renderer.go
package engo

import (
        "image/color"

        "github.com/EngoEngine/ecs"
        "github.com/EngoEngine/engo"
        "github.com/EngoEngine/engo/common"

        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/physics"
)

// EngoRenderer implements entity.Renderer using the Engo game engine
type EngoRenderer struct {
        world        *ecs.World
        renderSystem *common.RenderSystem

        // Entity management
        shipEntities       map[entity.ID]*ecs.BasicEntity
        planetEntities     map[entity.ID]*ecs.BasicEntity
        projectileEntities map[entity.ID]*ecs.BasicEntity

        // Asset management
        assets *AssetManager
}

// NewEngoRenderer creates a new Engo-based renderer
func NewEngoRenderer(world *ecs.World) *EngoRenderer <span class="cov0" title="0">{
        return &amp;EngoRenderer{
                world:              world,
                shipEntities:       make(map[entity.ID]*ecs.BasicEntity),
                planetEntities:     make(map[entity.ID]*ecs.BasicEntity),
                projectileEntities: make(map[entity.ID]*ecs.BasicEntity),
                assets:             NewAssetManager(),
        }
}</span>

// Initialize sets up the renderer's systems
func (r *EngoRenderer) Initialize() error <span class="cov0" title="0">{
        // Initialize render system
        r.renderSystem = &amp;common.RenderSystem{}
        r.world.AddSystem(r.renderSystem)

        // Load assets
        return r.assets.LoadAssets()
}</span>

// RenderShip implements entity.Renderer
func (r *EngoRenderer) RenderShip(ship *entity.Ship) <span class="cov0" title="0">{
        // Get or create entity for this ship
        basicEntity := r.getOrCreateShipEntity(ship.GetID())

        // Update ship rendering components
        r.updateShipComponents(basicEntity, ship)
}</span>

// RenderPlanet implements entity.Renderer
func (r *EngoRenderer) RenderPlanet(planet *entity.Planet) <span class="cov0" title="0">{
        // Get or create entity for this planet
        basicEntity := r.getOrCreatePlanetEntity(planet.GetID())

        // Update planet rendering components
        r.updatePlanetComponents(basicEntity, planet)
}</span>

// RenderProjectile implements entity.Renderer
func (r *EngoRenderer) RenderProjectile(projectile *entity.Projectile) <span class="cov0" title="0">{
        // Get or create entity for this projectile
        basicEntity := r.getOrCreateProjectileEntity(projectile.GetID())

        // Update projectile rendering components
        r.updateProjectileComponents(basicEntity, projectile)
}</span>

// Clear implements entity.Renderer
func (r *EngoRenderer) Clear() <span class="cov0" title="0">{
        // Engo handles clearing automatically, but we can clean up dead entities here
        r.cleanupInactiveEntities()
}</span>

// Present implements entity.Renderer
func (r *EngoRenderer) Present() {<span class="cov0" title="0">
        // Engo handles presentation automatically through its render system
        // This is called after all entities have been rendered
}</span>

// getOrCreateShipEntity gets an existing ship entity or creates a new one
func (r *EngoRenderer) getOrCreateShipEntity(id entity.ID) *ecs.BasicEntity <span class="cov0" title="0">{
        if entity, exists := r.shipEntities[id]; exists </span><span class="cov0" title="0">{
                return entity
        }</span>

        // Create new entity
        <span class="cov0" title="0">basicEntity := ecs.NewBasic()
        r.shipEntities[id] = &amp;basicEntity

        // Add to render system with initial components
        renderComponent := common.RenderComponent{
                Drawable: r.assets.GetShipSprite(entity.Scout), // Default ship
                Color:    color.RGBA{255, 255, 255, 255},
        }

        spaceComponent := common.SpaceComponent{
                Position: engo.Point{X: 0, Y: 0},
                Width:    32,
                Height:   32,
        }

        r.renderSystem.Add(&amp;basicEntity, &amp;renderComponent, &amp;spaceComponent)

        return &amp;basicEntity</span>
}

// getOrCreatePlanetEntity gets an existing planet entity or creates a new one
func (r *EngoRenderer) getOrCreatePlanetEntity(id entity.ID) *ecs.BasicEntity <span class="cov0" title="0">{
        if entity, exists := r.planetEntities[id]; exists </span><span class="cov0" title="0">{
                return entity
        }</span>

        // Create new entity
        <span class="cov0" title="0">basicEntity := ecs.NewBasic()
        r.planetEntities[id] = &amp;basicEntity

        // Add to render system with initial components
        renderComponent := common.RenderComponent{
                Drawable: r.assets.GetPlanetSprite(entity.Homeworld), // Default planet
                Color:    color.RGBA{255, 255, 255, 255},
        }

        spaceComponent := common.SpaceComponent{
                Position: engo.Point{X: 0, Y: 0},
                Width:    48,
                Height:   48,
        }

        r.renderSystem.Add(&amp;basicEntity, &amp;renderComponent, &amp;spaceComponent)

        return &amp;basicEntity</span>
}

// getOrCreateProjectileEntity gets an existing projectile entity or creates a new one
func (r *EngoRenderer) getOrCreateProjectileEntity(id entity.ID) *ecs.BasicEntity <span class="cov0" title="0">{
        if entity, exists := r.projectileEntities[id]; exists </span><span class="cov0" title="0">{
                return entity
        }</span>

        // Create new entity
        <span class="cov0" title="0">basicEntity := ecs.NewBasic()
        r.projectileEntities[id] = &amp;basicEntity

        // Add to render system with initial components
        renderComponent := common.RenderComponent{
                Drawable: r.assets.GetProjectileSprite("torpedo"), // Default projectile
                Color:    color.RGBA{255, 255, 0, 255},
        }

        spaceComponent := common.SpaceComponent{
                Position: engo.Point{X: 0, Y: 0},
                Width:    8,
                Height:   8,
        }

        r.renderSystem.Add(&amp;basicEntity, &amp;renderComponent, &amp;spaceComponent)

        return &amp;basicEntity</span>
}

// updateShipComponents updates the rendering components for a ship
func (r *EngoRenderer) updateShipComponents(basicEntity *ecs.BasicEntity, ship *entity.Ship) <span class="cov0" title="0">{
        // Update position
        if spaceComponent := r.getSpaceComponent(basicEntity); spaceComponent != nil </span><span class="cov0" title="0">{
                pos := r.worldToScreen(ship.Position)
                spaceComponent.Position = engo.Point{X: pos.X, Y: pos.Y}
                spaceComponent.Rotation = float32(ship.Rotation)
        }</span>

        // Update ship sprite and color based on class and team
        <span class="cov0" title="0">if renderComponent := r.getRenderComponent(basicEntity); renderComponent != nil </span><span class="cov0" title="0">{
                renderComponent.Drawable = r.assets.GetShipSprite(ship.Class)
                renderComponent.Color = r.getTeamColor(ship.TeamID)
        }</span>
}

// updatePlanetComponents updates the rendering components for a planet
func (r *EngoRenderer) updatePlanetComponents(basicEntity *ecs.BasicEntity, planet *entity.Planet) <span class="cov0" title="0">{
        // Update position
        if spaceComponent := r.getSpaceComponent(basicEntity); spaceComponent != nil </span><span class="cov0" title="0">{
                pos := r.worldToScreen(planet.Position)
                spaceComponent.Position = engo.Point{X: pos.X, Y: pos.Y}
        }</span>

        // Update planet sprite and color based on type and ownership
        <span class="cov0" title="0">if renderComponent := r.getRenderComponent(basicEntity); renderComponent != nil </span><span class="cov0" title="0">{
                renderComponent.Drawable = r.assets.GetPlanetSprite(planet.Type)
                if planet.TeamID &gt;= 0 </span><span class="cov0" title="0">{
                        renderComponent.Color = r.getTeamColor(planet.TeamID)
                }</span> else<span class="cov0" title="0"> {
                        renderComponent.Color = color.RGBA{128, 128, 128, 255} // Neutral
                }</span>
        }
}

// updateProjectileComponents updates the rendering components for a projectile
func (r *EngoRenderer) updateProjectileComponents(basicEntity *ecs.BasicEntity, projectile *entity.Projectile) <span class="cov0" title="0">{
        // Update position
        if spaceComponent := r.getSpaceComponent(basicEntity); spaceComponent != nil </span><span class="cov0" title="0">{
                pos := r.worldToScreen(projectile.Position)
                spaceComponent.Position = engo.Point{X: pos.X, Y: pos.Y}
        }</span>

        // Update projectile sprite and color based on type and team
        <span class="cov0" title="0">if renderComponent := r.getRenderComponent(basicEntity); renderComponent != nil </span><span class="cov0" title="0">{
                renderComponent.Drawable = r.assets.GetProjectileSprite(projectile.Type)
                renderComponent.Color = r.getTeamColor(projectile.TeamID)
        }</span>
}

// Helper functions to get components from entities
func (r *EngoRenderer) getSpaceComponent(entity *ecs.BasicEntity) *common.SpaceComponent <span class="cov0" title="0">{
        // In a real implementation, you would properly query the ECS for components
        // This is a simplified version for this example
        return nil
}</span>

func (r *EngoRenderer) getRenderComponent(entity *ecs.BasicEntity) *common.RenderComponent <span class="cov0" title="0">{
        // In a real implementation, you would properly query the ECS for components
        // This is a simplified version for this example
        return nil
}</span>

// worldToScreen converts world coordinates to screen coordinates
func (r *EngoRenderer) worldToScreen(worldPos physics.Vector2D) engo.Point <span class="cov0" title="0">{
        // Convert from game world coordinates to screen coordinates
        // This would take into account camera position and zoom
        return engo.Point{
                X: float32(worldPos.X) + engo.GameWidth()/2,
                Y: float32(worldPos.Y) + engo.GameHeight()/2,
        }
}</span>

// getTeamColor returns the color for a specific team
func (r *EngoRenderer) getTeamColor(teamID int) color.Color <span class="cov0" title="0">{
        teamColors := []color.Color{
                color.RGBA{255, 0, 0, 255},   // Red
                color.RGBA{0, 255, 0, 255},   // Green
                color.RGBA{0, 0, 255, 255},   // Blue
                color.RGBA{255, 255, 0, 255}, // Yellow
        }

        if teamID &gt;= 0 &amp;&amp; teamID &lt; len(teamColors) </span><span class="cov0" title="0">{
                return teamColors[teamID]
        }</span>

        <span class="cov0" title="0">return color.RGBA{255, 255, 255, 255}</span> // White for unknown teams
}

// cleanupInactiveEntities removes entities that are no longer active
func (r *EngoRenderer) cleanupInactiveEntities() {<span class="cov0" title="0">
        // This would be called to remove entities that are no longer in the game state
        // Implementation would depend on how the game signals entity removal
}</span>

// RemoveShip removes a ship entity from rendering
func (r *EngoRenderer) RemoveShip(id entity.ID) <span class="cov0" title="0">{
        if entity, exists := r.shipEntities[id]; exists </span><span class="cov0" title="0">{
                r.renderSystem.Remove(*entity)
                delete(r.shipEntities, id)
        }</span>
}

// RemovePlanet removes a planet entity from rendering
func (r *EngoRenderer) RemovePlanet(id entity.ID) <span class="cov0" title="0">{
        if entity, exists := r.planetEntities[id]; exists </span><span class="cov0" title="0">{
                r.renderSystem.Remove(*entity)
                delete(r.planetEntities, id)
        }</span>
}

// RemoveProjectile removes a projectile entity from rendering
func (r *EngoRenderer) RemoveProjectile(id entity.ID) <span class="cov0" title="0">{
        if entity, exists := r.projectileEntities[id]; exists </span><span class="cov0" title="0">{
                r.renderSystem.Remove(*entity)
                delete(r.projectileEntities, id)
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// pkg/render/engo/scene.go
package engo

import (
        "github.com/EngoEngine/ecs"
        "github.com/EngoEngine/engo"
        "github.com/EngoEngine/engo/common"

        "github.com/opd-ai/go-netrek/pkg/engine"
        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/event"
        "github.com/opd-ai/go-netrek/pkg/network"
)

// GameScene represents the main game scene in Engo
type GameScene struct {
        world *ecs.World

        // Network components
        client   *network.GameClient
        eventBus *event.Bus

        // Rendering components
        renderer *EngoRenderer
        camera   *CameraSystem
        input    *InputSystem
        hud      *HUDSystem

        // Game state
        gameState *engine.GameState
        playerID  uint64
}

// NewGameScene creates a new game scene
func NewGameScene(client *network.GameClient, eventBus *event.Bus, playerID uint64) *GameScene <span class="cov8" title="1">{
        return &amp;GameScene{
                client:   client,
                eventBus: eventBus,
                playerID: playerID,
                world:    &amp;ecs.World{},
        }
}</span>

// Type returns the scene type (required by Engo)
func (scene *GameScene) Type() string <span class="cov8" title="1">{
        return "GameScene"
}</span>

// Preload is called before the scene starts (required by Engo)
func (scene *GameScene) Preload() {<span class="cov8" title="1">
        // Load any assets here
}</span>

// Setup is called when the scene starts (required by Engo)
func (scene *GameScene) Setup(u engo.Updater) <span class="cov0" title="0">{
        // Set up the world
        scene.world = &amp;ecs.World{}

        // Add the common systems (required for Engo)
        scene.world.AddSystem(&amp;common.RenderSystem{})
        scene.world.AddSystem(&amp;common.MouseSystem{})

        // Initialize renderer
        scene.renderer = NewEngoRenderer(scene.world)
        if err := scene.renderer.Initialize(); err != nil </span><span class="cov0" title="0">{
                // Use panic instead of engo.Log which doesn't exist
                panic("Failed to initialize renderer: " + err.Error())</span>
        }

        // Initialize camera system
        <span class="cov0" title="0">scene.camera = NewCameraSystem()
        scene.world.AddSystem(scene.camera)

        // Initialize input system
        scene.input = NewInputSystem(scene.client)
        scene.world.AddSystem(scene.input)

        // Initialize HUD system
        scene.hud = NewHUDSystem()
        scene.world.AddSystem(scene.hud)

        // Subscribe to game state updates
        go scene.handleGameStateUpdates()

        // Subscribe to events
        scene.subscribeToEvents()</span>
}

// subscribeToEvents sets up event handlers
func (scene *GameScene) subscribeToEvents() <span class="cov0" title="0">{
        // Subscribe to chat events
        scene.eventBus.Subscribe("chat", func(e event.Event) </span><span class="cov0" title="0">{
                // Handle chat events
                scene.hud.AddChatMessage("System", "Event received")
        }</span>)
}

// handleGameStateUpdates processes game state updates from the client
func (scene *GameScene) handleGameStateUpdates() <span class="cov0" title="0">{
        for gameState := range scene.client.GetGameStateChannel() </span><span class="cov0" title="0">{
                scene.gameState = gameState
                scene.updateGame(gameState)
        }</span>
}

// updateGame updates the game state and renders the current frame
func (scene *GameScene) updateGame(gameState *engine.GameState) <span class="cov0" title="0">{
        // Clear the previous frame
        scene.renderer.Clear()

        // Render ships
        for _, shipState := range gameState.Ships </span><span class="cov0" title="0">{
                // Convert ShipState to Ship entity for rendering
                ship := scene.convertShipStateToEntity(shipState)
                scene.renderer.RenderShip(ship)

                // Update camera to follow player's ship if this is the player's ship
                if scene.isPlayerShip(uint64(shipState.ID)) </span><span class="cov0" title="0">{
                        scene.camera.SetTarget(shipState.Position)
                }</span>
        }

        // Render planets
        <span class="cov0" title="0">for _, planetState := range gameState.Planets </span><span class="cov0" title="0">{
                // Convert PlanetState to Planet entity for rendering
                planet := scene.convertPlanetStateToEntity(planetState)
                scene.renderer.RenderPlanet(planet)
        }</span>

        // Render projectiles
        <span class="cov0" title="0">for _, projectileState := range gameState.Projectiles </span><span class="cov0" title="0">{
                // Convert ProjectileState to Projectile entity for rendering
                projectile := scene.convertProjectileStateToEntity(projectileState)
                scene.renderer.RenderProjectile(projectile)
        }</span>

        // Update HUD with current game state
        <span class="cov0" title="0">scene.hud.UpdateGameState(gameState)

        // Present the rendered frame
        scene.renderer.Present()</span>
}

// convertShipStateToEntity converts a ShipState to a Ship entity for rendering
func (scene *GameScene) convertShipStateToEntity(shipState engine.ShipState) *entity.Ship <span class="cov8" title="1">{
        // Create a minimal ship entity for rendering purposes
        // Note: This is a simplified conversion - in a real implementation
        // you might want to maintain a mapping of entities
        return &amp;entity.Ship{
                BaseEntity: entity.BaseEntity{
                        ID:       shipState.ID,
                        Position: shipState.Position,
                        Rotation: shipState.Rotation,
                        Velocity: shipState.Velocity,
                        Active:   true,
                },
                Class:   shipState.Class,
                TeamID:  shipState.TeamID,
                Hull:    shipState.Hull,
                Shields: shipState.Shields,
                Fuel:    shipState.Fuel,
                Armies:  shipState.Armies,
        }
}</span>

// convertPlanetStateToEntity converts a PlanetState to a Planet entity for rendering
func (scene *GameScene) convertPlanetStateToEntity(planetState engine.PlanetState) *entity.Planet <span class="cov8" title="1">{
        return &amp;entity.Planet{
                BaseEntity: entity.BaseEntity{
                        ID:       planetState.ID,
                        Position: planetState.Position,
                        Active:   true,
                },
                Name:   planetState.Name,
                TeamID: planetState.TeamID,
                Armies: planetState.Armies,
        }
}</span>

// convertProjectileStateToEntity converts a ProjectileState to a Projectile entity for rendering
func (scene *GameScene) convertProjectileStateToEntity(projectileState engine.ProjectileState) *entity.Projectile <span class="cov8" title="1">{
        return &amp;entity.Projectile{
                BaseEntity: entity.BaseEntity{
                        ID:       projectileState.ID,
                        Position: projectileState.Position,
                        Velocity: projectileState.Velocity,
                        Active:   true,
                },
                Type:   projectileState.Type,
                TeamID: projectileState.TeamID,
        }
}</span>

// isPlayerShip checks if the given ship ID belongs to the current player
func (scene *GameScene) isPlayerShip(shipID uint64) bool <span class="cov8" title="1">{
        // This is a placeholder implementation
        // In a real implementation, you would track the player's ship ID
        return shipID == scene.playerID
}</span>

// Exit is called when the scene is exiting (required by Engo)
func (scene *GameScene) Exit() {<span class="cov8" title="1">
        // Clean up resources
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// pkg/render/renderer.go
package render

import (
        "log"

        "github.com/opd-ai/go-netrek/pkg/entity"
)

// NullRenderer is a simple implementation of entity.Renderer.
type NullRenderer struct{}

// Clear implements entity.Renderer.
func (d *NullRenderer) Clear() <span class="cov8" title="1">{
        log.Println("Clear called")
}</span>

// Present implements entity.Renderer.
func (d *NullRenderer) Present() <span class="cov8" title="1">{
        log.Println("Present called")
}</span>

// RenderPlanet implements entity.Renderer.
func (d *NullRenderer) RenderPlanet(planet *entity.Planet) <span class="cov8" title="1">{
        log.Printf("RenderPlanet called for planet: %v", planet)
}</span>

// RenderProjectile implements entity.Renderer.
func (d *NullRenderer) RenderProjectile(projectile *entity.Projectile) <span class="cov8" title="1">{
        log.Printf("RenderProjectile called for projectile: %v", projectile)
}</span>

// RenderShip implements entity.Renderer.
func (d *NullRenderer) RenderShip(ship *entity.Ship) <span class="cov8" title="1">{
        log.Printf("RenderShip called for ship: %v", ship)
}</span>

// NullRendererInstance is a global instance of NullRenderer for convenience.
var NullRendererInstance entity.Renderer = &amp;NullRenderer{}
</pre>
		
		<pre class="file" id="file23" style="display: none">package render

import (
        "fmt"
        "strings"

        "github.com/opd-ai/go-netrek/pkg/entity"
        "github.com/opd-ai/go-netrek/pkg/physics"
)

// TerminalRenderer provides a simple ASCII-based rendering for terminals
type TerminalRenderer struct {
        width     int
        height    int
        buffer    [][]rune
        scale     float64
        centerPos physics.Vector2D
}

// NewTerminalRenderer creates a new terminal renderer with the specified dimensions
func NewTerminalRenderer(width, height int, scale float64) *TerminalRenderer <span class="cov8" title="1">{
        buffer := make([][]rune, height)
        for i := range buffer </span><span class="cov8" title="1">{
                buffer[i] = make([]rune, width)
        }</span>

        <span class="cov8" title="1">return &amp;TerminalRenderer{
                width:  width,
                height: height,
                buffer: buffer,
                scale:  scale,
                centerPos: physics.Vector2D{
                        X: 0,
                        Y: 0,
                },
        }</span>
}

// SetCenter sets the center position of the view
func (r *TerminalRenderer) SetCenter(pos physics.Vector2D) <span class="cov8" title="1">{
        r.centerPos = pos
}</span>

// worldToScreen converts world coordinates to screen coordinates
func (r *TerminalRenderer) worldToScreen(pos physics.Vector2D) (int, int) <span class="cov8" title="1">{
        // Convert world coordinates to screen coordinates
        screenX := int((pos.X-r.centerPos.X)/r.scale + float64(r.width)/2)
        screenY := int((pos.Y-r.centerPos.Y)/r.scale + float64(r.height)/2)
        return screenX, screenY
}</span>

// Clear implements entity.Renderer
func (r *TerminalRenderer) Clear() <span class="cov8" title="1">{
        for y := range r.buffer </span><span class="cov8" title="1">{
                for x := range r.buffer[y] </span><span class="cov8" title="1">{
                        r.buffer[y][x] = ' '
                }</span>
        }
}

// Present implements entity.Renderer
func (r *TerminalRenderer) Present() <span class="cov8" title="1">{
        // Clear terminal
        fmt.Print("\033[H\033[2J")

        // Draw border
        fmt.Println("+" + strings.Repeat("-", r.width) + "+")

        // Draw buffer
        for y := range r.buffer </span><span class="cov8" title="1">{
                fmt.Print("|")
                for x := range r.buffer[y] </span><span class="cov8" title="1">{
                        fmt.Print(string(r.buffer[y][x]))
                }</span>
                <span class="cov8" title="1">fmt.Println("|")</span>
        }

        // Draw border
        <span class="cov8" title="1">fmt.Println("+" + strings.Repeat("-", r.width) + "+")</span>
}

// RenderShip implements entity.Renderer
func (r *TerminalRenderer) RenderShip(ship *entity.Ship) <span class="cov8" title="1">{
        x, y := r.worldToScreen(ship.Position)

        // Check if within bounds
        if x &gt;= 0 &amp;&amp; x &lt; r.width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; r.height </span><span class="cov8" title="1">{
                // Use different symbols based on ship class and team
                symbols := []rune{'S', 'D', 'C', 'B', 'A'}
                symbol := symbols[int(ship.Class)]

                // Add team-based coloring in a real implementation
                r.buffer[y][x] = symbol
        }</span>
}

// RenderPlanet implements entity.Renderer
func (r *TerminalRenderer) RenderPlanet(planet *entity.Planet) <span class="cov8" title="1">{
        x, y := r.worldToScreen(planet.Position)

        // Check if within bounds
        if x &gt;= 0 &amp;&amp; x &lt; r.width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; r.height </span><span class="cov8" title="1">{
                // Use O for planets
                r.buffer[y][x] = 'O'
        }</span>
}

// RenderProjectile implements entity.Renderer
func (r *TerminalRenderer) RenderProjectile(projectile *entity.Projectile) <span class="cov8" title="1">{
        x, y := r.worldToScreen(projectile.Position)

        // Check if within bounds
        if x &gt;= 0 &amp;&amp; x &lt; r.width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; r.height </span><span class="cov8" title="1">{
                // Use . for projectiles
                r.buffer[y][x] = '.'
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
